// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef FOLDER_H_
#define FOLDER_H_

#include <sys/types.h>
#include <dirent.h>
#include <boost/thread.hpp>
#include <vector>
#include <set>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/inotify.h>

#include "../Common/Common.h"

class Storage;
class File;

class Folder{
	friend class Storage;
	friend class File;
	private:
		unsigned getFileCount(){
			SERIALIZE_ACCESS();
			return files.size();
		}
		string getFileName(int i){// i is 0..n-1 or -1..-n
			SERIALIZE_ACCESS();
			unsigned c  = files.size();
			if (i < (-((int)c))) return "";
			if (i >= ((int)c))    return "";
			if (i<0){
				return files[c+i];
			} else {
				return files[i];
			}
		}
		unsigned getDirCount(){
			SERIALIZE_ACCESS();
			return dirs.size();
		}

		string getDirName(int i){ // i is 0..n-1 or -1..-n
			SERIALIZE_ACCESS();
			unsigned c  = dirs.size();
			if (i < (-((int)c))) return "";
			if (i >= ((int)c))    return "";
			if (i<0){
				return dirs[c+i];
			} else {
				return dirs[i];
			}
		}



		bool     isListeningChanges() const {return wtrunning;}
		FileType getFileType()        const {return fType;}
		string   getPath()            const {return path;}


		Folder(string path, FileType fType):fType(fType), path(path), files(), dirs(), watch_fd(-1), watch_wd(watch_wd), wt(NULL){
			__readContent();
			__setWatch();
		}

		~Folder(){
			__clearWatch();
		}
		Folder(){};

		void __readContent(){
			SERIALIZE_ACCESS();
			LOGC(L_DEBUG, "Watched folder re-read '"+path+"'", ACTOR_COLORS);
			files.clear();
			dirs.clear();
			DIR *d = opendir( path.c_str() );
			if (!d) return;
			struct dirent *de;
			while ((de = readdir(d)) != NULL){
				if (de->d_name[0] != '.'){ // no hidden, no . and ..
					string filename_full = path +"/" + de->d_name;
					struct stat fstat;
					if (stat( filename_full.c_str(), &fstat ) == 0){
						if (S_ISDIR( fstat.st_mode )){
							dirs.push_back(de->d_name);
						} else if (S_ISREG( fstat.st_mode )){
							files.push_back(de->d_name);
						} else {
							// don't care
						}
					}
				}
			}
			closedir(d);
		}

		void __clearWatch(){
			if (watch_fd != -1){
				close(watch_fd);
				if (wt != NULL){
					wtrunning=false;
					wt->join();
				}
			}
			watch_fd = -1;
			watch_wd = -1;
			wt = NULL;
		}
		void __setWatch(){
			watch_fd = inotify_init1(IN_NONBLOCK);
			if (watch_fd == -1){
				cout << "Warning: cannot init inotify on '"+path+"'\n";
				return;
			}
			watch_wd = inotify_add_watch(watch_fd, path.c_str(), IN_CREATE | IN_DELETE | IN_DELETE_SELF);
			if (watch_wd == -1){
				cout << "Warning: cannot add watch on '" + path + "'\n";
				return;
			}
			wt = new boost::thread(boost::bind(&Folder::__watchThread, this));
			if (!wt){
				cout << "Warning: cannot init watch thread on '"+path+"'\n";
				return;
			}

		}
		void __watchThread(){
			wtrunning = true;
			ThreadManager::getInstance()->announceSelf("Folder Watcher");
			char buf [4096];
			//struct inotify_event* ev = (struct inotify_event*)(&(buf[0]));
			struct timeval to;
			fd_set readfds,writefds,errfds;

			while (wtrunning){
				FD_ZERO(&readfds);  FD_SET(watch_fd,&readfds);
				FD_ZERO(&writefds); FD_SET(watch_fd,&writefds);
				FD_ZERO(&errfds);   FD_SET(watch_fd,&errfds);
				to.tv_sec=0;
				to.tv_usec=500000;
				switch(int res1 = select(watch_fd+1,&readfds,&writefds,&errfds,&to)){
					case  0: break; // timeout
					case -1: if (errno != EINTR) LOGC(L_DEBUG, "Watched folder select error '"+string(strerror(errno))+"'", ACTOR_ERROR_COLORS); break;
					default:
						LOGC(L_DEBUG, "Watched folder '"+path+"' select returned " + LXS(res1), ACTOR_ERROR_COLORS);
						if (FD_ISSET(watch_fd,&readfds)){
							int res = read( watch_fd,(void*)buf, 4096);
							switch(res){
							case -1:
								LOGC(L_DEBUG, "Watched folder read error '"+string(strerror(errno))+"'", ACTOR_ERROR_COLORS);
								break;
							case 0:                   break;
							default: __readContent(); break;
							}
						}
						break;
				}
			}
		}

		FileType fType;
		string path;
		vector<string> files;
		vector<string> dirs;
		int watch_fd;
		int watch_wd;
		DECLARE_ACCESS_MUTEX();
		boost::thread* wt;
		volatile bool wtrunning;

	};

#endif /* FOLDER_H_ */
