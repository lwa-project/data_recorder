// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "ParcelMemQueue.h"
#include "../Common/branchPredict.h"
#include <cstdlib>
#include <iostream>
using namespace std;

ParcelMemQueue::ParcelMemQueue(
		const size_t &numParcels,
		const size_t &size,
		const size_t &outChunk,
		const bool &clearUnused):
		ParcelQueue(numParcels,size/outChunk,clearUnused),
		size(size),
		outChunk(outChunk),
		allocSize((((size/outChunk)+1)*outChunk)),
		numChunks(size/outChunk),
		in(0),
		out(0),
		valid(false)
		{
		cout << "\n\n ParcelMemQueue constructor entered ("<<numParcels << "," << size << ","<< outChunk << "," << clearUnused<<").\n\n";

		buf = malloc(allocSize);
		if (!buf) return;
		valid=ParcelQueue::isValid();
}
Allocation* lsto=NULL;
Allocation* ParcelMemQueue::nextOut(){
	if(unlikely(!valid)) return NULL;
	Allocation* atmp = nextAllocOut();
	if (atmp){
		lsto = atmp;
	}else{
		lsto = NULL;
	}
	while(RQ_FREE(in,out,numChunks) && ((atmp=nextAllocIn())!=NULL)){
		atmp->iov_base = PTR_TO_BYTE(buf,(in*outChunk));
		atmp->iov_len  = outChunk;
		doneAllocIn(atmp);
		in = RQ_NEXT(in,numChunks);
	}

	return lsto;

}
void ParcelMemQueue::doneOut(Allocation* ptr){
	if(unlikely(!valid)) return;
	Allocation* atmp = nextAllocOut();
	if (ptr != atmp){
		FATAL(USAGE_ERROR,"called done out on other than the output object [0x" << hex << (size_t) lsto << " != 0x" << hex << (size_t) ptr << " != " << hex << (size_t) atmp);
	}
	if (!RQ_USED(in,out,numChunks)){
		FATAL(PROGRAM_ERROR,"called doneOut but no objects in use.");
	}
	out = RQ_NEXT(out,numChunks);
	doneAllocOut(ptr);
}
void ParcelMemQueue::reset(){
	if(unlikely(!valid)) return;
	in=0;
	out=0;
	ParcelQueue::reset();
}
void ParcelMemQueue::print()const{
	size_t pused     = pbuf.used();
	size_t a_allocd  = abuf.usedInStage(0);
	size_t a_using   = abuf.usedInStage(1);
	size_t a_used    = abuf.usedInStage(2);
	size_t a_total_u = abuf.used();
	cout << "\tPMQ-P  [ " << setw(10) << 0 << " / " << setw(10) << 0 << " / " << setw(15) << pused << " ]";
	progressbar((pused*100ll)/pbuf.size(),25);
	cout << "\n";
	cout << "\tPMQ-A  [ " << setw(10) << a_allocd << " / " << setw(10) << a_using << " / " << setw(15) << a_used << " ]";
	progressbar((a_total_u*100ll)/abuf.size(),25);
	cout << "\n";
}

ParcelMemQueue::~ParcelMemQueue() {
	if (buf!=NULL)
		free(buf);
}

