// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef SIGNALEXCEPTION_H_
#define SIGNALEXCEPTION_H_

#include <csignal>
#include <exception>
#include "BackTrace.h"


class SignalException: public BackTrace, public std::exception{
private:
	int signo;
	string w;
	SignalException():BackTrace(NULL,NULL){};
public:
	SignalException(int _signo, siginfo_t *info, ucontext_t *uc):BackTrace(info,uc), exception(), signo(_signo), w(){
		w = "\n"
			"============= ============= ============ Signal caught ============ ============= =============\n" +
			getSigInfo(signo) + "\n" +
			"============= ============= ============= Stack Trace ============= ============= =============\n" +
			BackTrace::toString();
	}

	virtual const char* what() const throw(){
		return w.c_str();
	}
	static string getSigInfo(int sig){
		// according to http://linux.about.com/od/commands/l/blcmdl7_signal.htm
		switch (sig){
			case SIGINT:      return "SIGINT:      Interrupt from keyboard";
			case SIGQUIT:     return "SIGQUIT:     Quit from keyboard";
			case SIGILL:      return "SIGILL:      Illegal Instruction";
			case SIGABRT:     return "SIGABRT:     Abort signal from abort(3)";
			case SIGFPE:      return "SIGFPE:      Floating point exception";
			case SIGKILL:     return "SIGKILL:     Kill signal";
			case SIGSEGV:     return "SIGSEGV:     Invalid memory reference";
			case SIGPIPE:     return "SIGPIPE:     Broken pipe: write to pipe with no readers";
			case SIGALRM:     return "SIGALRM:     Timer signal from alarm(2)";
			case SIGTERM:     return "SIGTERM:     Termination signal";
			case SIGUSR1:     return "SIGUSR1:     User-defined signal 1";
			case SIGUSR2:     return "SIGUSR2:     User-defined signal 2";
			case SIGCHLD:     return "SIGCHLD:     Child stopped or terminated";
			case SIGCONT:     return "SIGCONT:     Continue if stopped";
			case SIGSTOP:     return "SIGSTOP:     Stop process";
			case SIGTSTP:     return "SIGTSTP:     Stop typed at tty";
			case SIGTTIN:     return "SIGTTIN:     tty input for background process";
			case SIGTTOU:     return "SIGTTOU:     tty output for background process";
			case SIGPOLL:     return "SIGPOLL:     Pollable event (Sys V). Synonym of SIGIO";

			case SIGPROF:     return "SIGPROF:     Profiling timer expired";
			case SIGSYS:      return "SIGSYS:      Bad argument to routine (SVID)";
			case SIGTRAP:     return "SIGTRAP:     Trace/breakpoint trap";
			case SIGURG:      return "SIGURG:      Urgent condition on socket (4.2 BSD)";
			case SIGVTALRM:   return "SIGVTALRM:   Virtual alarm clock (4.2 BSD)";
			case SIGXCPU:     return "SIGXCPU:     CPU time limit exceeded (4.2 BSD)";
			case SIGXFSZ:     return "SIGXFSZ:     File size limit exceeded (4.2 BSD)";

			//case SIGEMT:      return "SIGEMT:      SIGEMT";
			case SIGSTKFLT:   return "SIGSTKFLT:   Stack fault on coprocessor (unused)";
			//case SIGIO:       return "SIGIO:       I/O now possible (4.2 BSD)";
			//case SIGCLD:      return "SIGCLD:      A synonym for SIGCHLD";
			case SIGPWR:      return "SIGPWR:      Power failure (System V)";
			//case SIGINFO:     return "SIGINFO:     A synonym for SIGPWR";
			//case SIGLOST:     return "SIGLOST:     File lock lost";
			case SIGWINCH:    return "SIGWINCH:    Window resize signal (4.3 BSD, Sun)";
			//case SIGUNUSED:   return "SIGUNUSED:   SIGUNUSED";

			default:        return "Unknown signal caught";
		}
	}
	virtual ~SignalException() throw(){}
};

#endif /* SIGNALEXCEPTION_H_ */
