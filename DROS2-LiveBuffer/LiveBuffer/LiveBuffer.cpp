// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "LiveBuffer.h"
#include "../Common/misc.h"
#include "../System/Log.h"

LiveBuffer::LiveBuffer(TicketBuffer* buf):
	SubscriberThread("LiveBuffer",buf),
	mtx_config_(),
	_max_cap_buffs(DEFAULT_BUFFER_COUNT),
	_max_chunks_per_buf(DEFAULT_CHUNKS_PER_BUF),
	_rule(),
	_rate_limit(0.0),
	_auto_ip(),
	_auto_port(),
	_config_changed(true),
	_capture_state(),
	_free_buffers(),
	_full_buffers(),
	_tx(&_full_buffers, &_free_buffers),
	_rptt(5000),
	_no_ticket_count(0),
	_tickets_processed(0),
	_frames_processed(0),
	_caps_started(0),
	_caps_dropped(0)

	{

	_capture_state._ip                 = NULL;
	_capture_state._filling            = NULL;

	_capture_state._max_chunks_per_buf = DEFAULT_CHUNKS_PER_BUF;
	_capture_state._max_cap_buffs      = DEFAULT_BUFFER_COUNT;
	_capture_state._count_cap_buffs    = 0;

	_capture_state._n                  = 0;
	_capture_state._fs                 = 0;
	_capture_state._capturing          = false;
	_capture_state._serv_trg           = false;

	_capture_state._rule._N            = 0;
	_capture_state._rule._N0           = 0;
	_capture_state._rule._auto_trigger = false;
	_capture_state._rule._vampire_full = false;

	_rule._N                           = 0;
	_rule._N0                          = 0;
	_rule._auto_trigger                = false;
	_rule._vampire_full                = false;


}

LiveBuffer::~LiveBuffer(){
	if (_capture_state._ip != NULL){
		delete (_capture_state._ip);
	}
}

// Capture configuration
void LiveBuffer::configure_memory(size_t max_chunks_per_buf, size_t max_cap_buffs){
	SERIALIZE_ACCESS(config);
	_max_chunks_per_buf = max_chunks_per_buf;
	_max_cap_buffs      = max_cap_buffs;
	_config_changed     = true;
}

void LiveBuffer::configure_capture(size_t period, size_t keep_count, bool vampire_full, bool auto_trigger_cap){
	SERIALIZE_ACCESS(config);
	_rule._N            = period;
	_rule._N0           = keep_count;
	_rule._vampire_full = vampire_full;
	_rule._auto_trigger = auto_trigger_cap;
	_config_changed     = true;
}

void LiveBuffer::configure_retrieval(std::string auto_ip, unsigned short auto_port, double rate_limit){
	SERIALIZE_ACCESS(config);
	_auto_ip            = auto_ip;
	_auto_port          = auto_port;
	_rate_limit         = rate_limit;
	_config_changed     = true;
}

// Receiver logic
void LiveBuffer::trigger_capture(){
	_capture_state._trigger.trigger();
}



bool LiveBuffer::is_current_config_valid()const{
	bool a_problem = (
		(_capture_state._ip == NULL)     	||
		!_capture_state._rule._N          	||
		!_capture_state._rule._N0         	||
		!_capture_state._max_chunks_per_buf	||
		!_capture_state._max_cap_buffs    	||
		!_capture_state._ip_ok
	);

	return not a_problem;
}

void LiveBuffer::read_config(){
	if (_config_changed){
		// memory / buffers
		_capture_state._max_chunks_per_buf = _max_chunks_per_buf;
		_capture_state._max_cap_buffs = _max_cap_buffs;

		// capture config
		_capture_state._rule = _rule;

		// retrieval config
		if (_capture_state._ip != NULL){
			delete (_capture_state._ip);
			_capture_state._ip = NULL;
		}
		IpSpec* tmp = new IpSpec(_auto_ip + ":" + LXS(_auto_port));
		bool ipok   =
				tmp->hasIp() &&
				tmp->hasPort() &&
				tmp->isIp() &&
				tmp->isIpv4();
		if (!ipok){
			delete tmp;
			_capture_state._ip         = NULL;
			bzero((void*) &_capture_state._d_addr, sizeof(struct sockaddr_storage));
		} else {
			_capture_state._ip         = tmp;
			_capture_state._ip->pack(_capture_state._d_addr);
		}
		_capture_state._ip_ok      = ipok;
		_capture_state._rate_limit = _rate_limit;
		_config_changed = false;
	}
}

bool LiveBuffer::check_config(){
	SERIALIZE_ACCESS(config);
	read_config();
	return is_current_config_valid();
}

bool LiveBuffer::acquire_buffer(size_t  size){
	// get a new buffer
	// 1) from _free pool
	// 2) new if not exceeds mem limit or buffer cap
	// 3) from used if vampire

	Capture* cap = NULL;

	// do free-pool cleanup
	while(	( _capture_state._count_cap_buffs < _capture_state._max_cap_buffs ) &&
			( (cap = _free_buffers.remove()) != NULL)								){
		delete (cap);
		_capture_state._count_cap_buffs--;
	}

	// if there's free buffers, just grab one
	if ( (cap = _free_buffers.remove()) != NULL){
			// got one from the free pool
			goto buf_acquired;
	} else if ( _capture_state._count_cap_buffs < _capture_state._max_cap_buffs ){
		cap = new Capture(_capture_state._max_chunks_per_buf);
		assert(cap != NULL);
		_capture_state._count_cap_buffs ++;
		goto buf_acquired;
	} else if ((_capture_state._rule._vampire_full) && ((cap = _full_buffers.remove()) != NULL)){
		// got one from the used pool
		cap->cancel();
		goto buf_acquired;
	} else {
		// no buffers
		return false;
	}

	buf_acquired:
		cap->set_rule(
			_capture_state._max_chunks_per_buf,
			_capture_state._d_addr,
			_capture_state._rate_limit,
			_capture_state._rule._N0
		);
		_capture_state._n         = 0;
		_capture_state._filling   = cap;
		_capture_state._capturing = true;
		return true;


}

void LiveBuffer::report(){
	stringstream ss("");
	SERIALIZE_ACCESS(config);
	ss << "Config:      ";
	ss << ((_capture_state._rule._N0 != 0) ?
			(ANSI::colorSpec(basic,magenta,black) + "enabled " + ANSI::colorSpec(basic,white,black)) :
			(ANSI::colorSpec(basic,yellow,black)  + "disabled" + ANSI::colorSpec(basic,white,black))
			);
	ss << ", ";
	ss << _capture_state._rule._N0 << "/" << _capture_state._rule._N << ", ";
	if (_capture_state._rule._auto_trigger){
		ss << "automatic";
	} else {
		ss << "manual";
	}
	if (_capture_state._rule._vampire_full){
		ss << " [vampire]";
	}
	ss << "\nDestination: ";
	if ((_capture_state._ip == NULL) || (!_capture_state._ip_ok)){
		ss <<
			ANSI::colorSpec(bold,yellow,black) <<
			"<Not configured>" <<
			ANSI::colorSpec(basic,white,black);
	} else {
		ss <<
			ANSI::colorSpec(bold,green,black) <<
			_capture_state._ip->toString() <<
			ANSI::colorSpec(basic,white,black) <<
			" @ ";
		if (_capture_state._rate_limit == 0.0){
			ss <<
				ANSI::colorSpec(bold,red,black) <<
				"Unlimited";
		} else {
			ss <<
				ANSI::colorSpec(bold,yellow,black) <<
				Storage::humanReadableBW(_capture_state._rate_limit);
		}
		ss << ANSI::colorSpec(basic,white,black);
	}
	ss << "\nBuffers:     ";
	int pct = (
		(_capture_state._max_cap_buffs) ?
		((_capture_state._count_cap_buffs * 100llu) / _capture_state._max_cap_buffs) :
		0
	);
	if ((pct >= 0)  && (pct < 25)) ss << ANSI::colorSpec(basic,green,black);
	if ((pct >= 25) && (pct < 50)) ss << ANSI::colorSpec(bold,yellow,black);
	if ((pct >= 50)              ) ss << ANSI::colorSpec(bold,red,black);
	progressbar(pct, 30, ss);
	ss << ANSI::colorSpec(basic,white,black);
	ss << "\nStats:       ";
	ss
		<< "{"
			<< _tickets_processed << ", "
			<< _caps_started << ", "
			<< _caps_dropped
		<< "}";

	LOG(L_INFO, ss.str());
}

void LiveBuffer::done_filling(bool keep){
	if (_capture_state._filling){
		if (keep){
			_capture_state._filling->prepare_for_transmission();
			_full_buffers.insert(_capture_state._filling);
			++_caps_started;
		} else {
			_capture_state._filling->cancel();
			delete(_capture_state._filling);
			++_caps_dropped;
		}
		_capture_state._filling   = NULL;
	}
}

bool LiveBuffer::check_trigger(){
	// check/cache asynchronous trigger
	size_t __attribute__((unused)) ignored;
	_capture_state._serv_trg = _capture_state._trigger.check(ignored);
	return (_capture_state._serv_trg || _capture_state._rule._auto_trigger);
}
void LiveBuffer::reset_trigger(){
	///LOGC(L_DEBUG,__PRETTY_FUNCTION__, ACTOR_WARNING_COLORS);
	if (_capture_state._serv_trg){
		_capture_state._trigger.service();
	}
	_capture_state._serv_trg = false;
}

void LiveBuffer::reset_capture(){
	///LOGC(L_DEBUG,__PRETTY_FUNCTION__, ACTOR_WARNING_COLORS);
	reset_trigger();
	_capture_state._n         = 0;
	_capture_state._capturing = false;
}

void LiveBuffer::cancel_capture(){
	///LOGC(L_DEBUG,__PRETTY_FUNCTION__, ACTOR_WARNING_COLORS);
	Capture* cap = _capture_state._filling;
	if (cap!=NULL){
		cap->cancel();
		_free_buffers.insert(cap);
		_capture_state._filling = NULL;
	}
	reset_capture();
}

// Subscriber Thread implementation
bool LiveBuffer::onInit(){
	_tx.start();
	return true;
}

bool LiveBuffer::onTicketReceived(TicketBuffer::Ticket* t){
	if (_rptt.isTimeToReport()){
		report();
	}
	///LOGC(L_DEBUG,"START TICKET: " + LXS(t->cnt_used) , FATAL_COLORS);
	size_t frames_consumed = 0;
	assert(t->cnt_used != 0);
	assert(t->fsize != 0);
	while ((frames_consumed != t->cnt_used) && ! isInterrupted()){
		///LOGC(L_DEBUG,"LOOP TOP", ACTOR_ERROR_COLORS)
		size_t consumed_start = frames_consumed;
		// either we're already capturing, or we're not; figure it out
		if (_capture_state._capturing){ // a capture is in progress
			///LOGC(L_DEBUG,"CAP IN PROGRESS", ACTOR_ERROR_COLORS)
			Capture* cap = _capture_state._filling;
			if (cap != NULL){
				///LOGC(L_DEBUG,"CAP NOT NULL", ACTOR_ERROR_COLORS)
				///if (cap->get_n() == 0){
				///	LOGC(L_DEBUG,"START CAPTURE", ACTOR_ERROR_COLORS);
				///}

				// have not completed hold portion of capture
				bool finished_hold = cap->insert(t,frames_consumed);
				size_t consumed    = frames_consumed - consumed_start;
				_frames_processed += consumed;
				_capture_state._n += consumed;
				///LOGC(L_DEBUG,"CONSUME <0> " + LXS(consumed), FATAL2_COLORS);
				if (finished_hold){
					bool complete = cap->isComplete();
					///if (complete){
					///	LOGC(L_DEBUG,"FINISH HOLD -- COMPLETE", ACTOR_ERROR_COLORS);
					///} else {
					///	LOGC(L_DEBUG,"FINISH HOLD -- INCOMPLETE", ACTOR_ERROR_COLORS);
					///}
					done_filling(complete);
					if (!complete){
						///LOGC(L_DEBUG,"FINISH CAPTURE -- INCOMPLETE", ACTOR_ERROR_COLORS);
						reset_capture();
					}
				} else {
					continue;
				}
			} else {
				///LOGC(L_DEBUG,"CAP NULL", ACTOR_ERROR_COLORS)
				// have completed hold portion of capture, now in drop portion of capture
				size_t avail  = t->cnt_used - frames_consumed;
				size_t needed =  _capture_state._rule._N - _capture_state._n;
				size_t toUse  = (needed < avail) ? needed : avail;
				_capture_state._n += toUse;
				frames_consumed   += toUse;
				_frames_processed += toUse;
				///LOGC(L_DEBUG,"CONSUME <1> " + LXS(toUse), FATAL2_COLORS);
				if (_capture_state._n ==  _capture_state._rule._N){
					///LOGC(L_DEBUG,"FINISH CAPTURE -- COMPLETE", ACTOR_ERROR_COLORS);
					reset_capture();
				} else {
					continue;
				}
			}
		} else {// no capture is in progress
			///LOGC(L_DEBUG,"NO CAP IN PROGRESS", ACTOR_ERROR_COLORS)
			// check for valid config (read changes 1st if any)
			if (check_config()){ // good config for possible capture
				if (check_trigger()){
					///LOGC(L_DEBUG,"TRIGGERED", ACTOR_WARNING_COLORS);
					if (acquire_buffer(_capture_state._rule._N0)){  // have a buffer we can use
						///LOGC(L_DEBUG,"BUFFER ACQUIRED", ACTOR_WARNING_COLORS);
						// we don't want to duplicate logic here, so just continue without consumption
						// since aquire_buffer() prepares geometry and sets capturing flag
						continue;
					} else {                   						// no free buffers; reset trigger, then consume frames and continue
						///LOGC(L_DEBUG,"BUFFER NOT ACQUIRED", ACTOR_ERROR_COLORS);
						reset_trigger();
						_frames_processed += t->cnt_used - frames_consumed;
						///LOGC(L_DEBUG,"CONSUME <2> " + LXS(t->cnt_used - frames_consumed), FATAL2_COLORS);
						frames_consumed = t->cnt_used;
						continue;
					}
				} else {
					///LOGC(L_DEBUG,"NO TRIGGER CONSUME", ACTOR_ERROR_COLORS);
					// not triggered; just consume frames and continue
					_frames_processed += t->cnt_used - frames_consumed;
					///LOGC(L_DEBUG,"CONSUME <3> " + LXS(t->cnt_used - frames_consumed), FATAL2_COLORS);

					frames_consumed = t->cnt_used;
					continue;
				}
			} else {
				///LOGC(L_DEBUG,"BAD CONFIG CONSUME", ACTOR_ERROR_COLORS);
				// bad config, disabled, etc.; just consume frames and continue
				_frames_processed += t->cnt_used - frames_consumed;
				///LOGC(L_DEBUG,"CONSUME <4> " + LXS(t->cnt_used - frames_consumed), FATAL2_COLORS);
				frames_consumed = t->cnt_used;
				continue;
			}
		}
	}
	///LOGC(L_DEBUG,"FINISH TICKET", FATAL2_COLORS);
	// finished with this ticket
	++_tickets_processed;
	t->put();

	return true;
}
bool LiveBuffer::onTicketBufferEmpty(){
	++_no_ticket_count;
	if (_rptt.isTimeToReport()){
		report();
	}
	usleep(100000);
	return true;
}

void LiveBuffer::onUninit(){
	LOGC(L_INFO,"Shutting down", ACTOR_COLORS);
	Capture* cap = NULL;
	// shut down transmitter thread; blocks...
	_tx.shutdown();

	// reset capture in progress, if there is one
	if (_capture_state._capturing){
		LOGC(L_INFO,"Cancel capture-in-progress", ACTOR_COLORS);
		cancel_capture();
		LOGC(L_INFO,"Finished cancel of capture-in-progress", ACTOR_COLORS);
	}
	// free resources
	// cancel "full" capture buffers and move to free list
	LOGC(L_INFO,"Draining unclaimed capture buffers", ACTOR_COLORS);
	while ((cap=_full_buffers.remove()) != NULL){
		cap->cancel();
		_free_buffers.insert(cap);
	}

	// free "free" capture buffers
	LOGC(L_INFO,"Freeing capture buffers", ACTOR_COLORS);
	while ((cap=_free_buffers.remove()) != NULL){
		delete cap;
		--_capture_state._count_cap_buffs;
	}
	assert(_capture_state._count_cap_buffs == 0);
	LOGC(L_INFO,"Shuttdown complete", ACTOR_COLORS);
}
void LiveBuffer::onDone(){
}

