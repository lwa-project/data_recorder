// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "MessageProcessor.h"
#include "ResponseSender.h"

#include "../Common/Common.h"
#include <boost/assign.hpp>
#include "../Common/Utility.h"
#include "../Actors/Schedule.h"
#include "../Operations/Operations.h"
#include "../Data/DataFormat.h"
#include "../Actors/Receiver.h"
//#include "../Spectrometer/DrxSpectrometer.h"
#include "../LiveBuffer/LiveBuffer.h"

using namespace boost::assign;

#define __opt Utility::__opt
#define __or Utility::__or
#define __rem Utility::__rem



MessageProcessor::MessageProcessor(size_t waitTime):
	WaitThread<Message>("MessageProcessor",waitTime){
}
void MessageProcessor::process(const Message& msg){
	SERIALIZE_ACCESS_ST();
	if (SAFE_GET(System,en_LogMessaging)){
		LOGC(L_INFO, ">> " + msg.toString(true, true), MESSAGING_COLORS);
	}
	WaitQueue<Message>* wq = WaitQueueManager::getInstance()->getByName<Message>("MessageProcessor");
	if (!wq){
		LOGC(L_ERROR, "[MessageProcessor] : Cannot access message queue; message dropped.", MESSAGING_ERROR_COLORS);
		LOGC(L_ERROR, "[MessageProcessor] : " + msg.toString(false), MESSAGING_ERROR_COLORS);
		return;
	} else {
		wq->enqueue(msg);
		//LOGC(L_DEBUG, "EE " + msg.toString(false), MESSAGING_COLORS );
	}
}
string resourceTypeString(StorageType st, FileType ft){
	switch (st){
	case ST_INTERNAL:
		switch (ft){
		case FT_GENERAL:      return "tag file"; break;
		case FT_SPECTROMETER: return "spectrometer file"; break;
		default:              break;
		}break;
	case ST_EXTERNAL:
		return "external file"; break;
	case ST_NETWORK:
		return "network resource"; break;
	default: break;
	}
	return ">>unknown resource type<<";
}
#define RESPOND(a,c) ResponseSender::respond(received,a,c); return false;
static void checkAndSchedule(Schedule* sch, ScheduledOperation* op, bool& accept, string& comment){
	ScheduledOperation* conflict;
	if (!op){
		accept = false;
		comment = "Program error: failed to allocate operation object";
		return;
	}
	if (sch->scheduleOperation(op,conflict)){
		accept = true;
		comment = "Operation scheduled";
		return;
	}
	if (conflict != NULL){
		accept = false;
		comment = "Operation not scheduled due to time conflict with " + conflict->toString() ;
	} else {
		accept = false;
		comment = "Operation not scheduled due to bad pointer" ;
	}
	delete(op);
}


static void openIn(Storage *device, const FileType type, const string& name, File*& file, bool& accept, string& comment){
	string rt = resourceTypeString(device->getStorageType(), type);
	file = device->getInFile(type, name);
	if (file == NULL){
		accept = false; comment = "Unknown "+rt+" '"+name+"'"; return;
	}
	if (!file->exists()){
		device->putFile(file);
		accept = false; comment = "Unknown "+rt+" '"+name+"'"; return;
	}
	if (!file->isOpen()){
		device->putFile(file);
		accept = false; comment = "Cannot open input "+rt+" '"+name+"'"; return;
	}
	accept = true; comment="";
}

static void openOut(Storage *device, const FileType type, const string& name, File*& file, const size_t prealloc, bool& accept, string& comment){
	string rt = resourceTypeString(device->getStorageType(), type);
	file = device->getOutFile(type, name, prealloc);
	if (file == NULL){
		accept = false; comment = "Can't create "+rt+" '"+name+"', or already exists"; return;
	}
	if (!file->exists()){
		device->putFile(file);
		accept = false; comment = "Program error: "+rt+" '"+name+"' not created as expected"; return;
	}
	if (!file->isOpen()){
		device->putFile(file);
		accept = false; comment = "Cannot open output "+rt+" '"+name+"'"; return;
	}
	accept = true; comment="";
}



bool MessageProcessor::onDoReceive(Message& received){

	bool                accept     = true;
	string              comment    = "";
	string              type       = received.getType();
	Storage*            s_internal = NULL;
	Storage*            s_external = NULL;
	Schedule*           sch        = NULL;
	StringList          sl;
	File*               tagfile    = NULL;
	File*               extfile    = NULL;
	deque<File*>        extfiles;
	StringStringMap     sm         = received.getMeta();
	if (!sm.empty()){
		int i=0;
		foreach(StringStringMap::value_type pair, sm){
			LOGC(L_DEBUG, "Metadata " + LXS(i++) + ": '" + pair.first + "' ==> '"+pair.second+"'", ACTOR_WARNING_COLORS);
		}
	}

	if (!isCommand(type)){
		LOG(L_WARNING, "[MessageProcessor] Unknown command type '"+type+"'.");
		RESPOND( false, "Unknown Command");
	}

	string data = received.getData();
	if (!isProperlyFormatted(type,data)){
		LOG(L_WARNING, "[MessageProcessor] Bad format for command type '"+type+"' with data '"+data+"' and regex '"+getCommandFormatRegEx(type)+"'.");
		RESPOND( false, "Bad format for command type '"+type+"'.");
	}

	//*************************************************************************
	// instant commands
	//*************************************************************************


	/////////////////////////////////////////////////////////
	// these commands are process-on-respond to avoid races
	/////////////////////////////////////////////////////////
	if (    !type.compare("SHT") ||
			!type.compare("EXT") ||
			!type.compare("INI") ||
			!type.compare("PNG") ||
			!type.compare("ECH")
		){
		RESPOND( true, "");
	}

	//*************************************************************************
	// regular commands
	//*************************************************************************
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("RPT")){
		getMib(received, accept, comment);
		RESPOND( accept, comment);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("SEL")){
		SYSTEM_SAFE(setDefaultStorage(data, accept, comment));
		RESPOND( false, comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("DVN")){
		SYSTEM_SAFE2(s_internal, getDefaultStorage(accept, comment), NULL);
		if (s_internal==NULL || !accept){
			RESPOND( false, comment);
		}
		if (!s_internal->getVolumeName().compare(data)){
			RESPOND( false, "DRSU volume name was already '"+data+"'");
		} else{
			if (!s_internal->setVolumeName(data)){
				RESPOND( false, "Illegal characters in volume name, volume name too long (max = 16), or I/O error.");
			} else {
				RESPOND( true, "DRSU volume name changed to '"+data+"'");
			}
		}

	}

	//*************************************************************************
	// not scheduled, but long running
	//*************************************************************************

	if (!type.compare("DWN")){
		string rescan = received.getMetaValue("RescanStorage");
		bool full = false;
		if (!rescan.compare("yes")){
			full=true;
		}
		SYSTEM_SAFE(requestDown(accept, comment, full));
		RESPOND( accept, comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	if (!type.compare("UP") || !type.compare("UP ") || !type.compare(" UP")){
		SYSTEM_SAFE(requestUp(accept, comment));
		RESPOND( accept, comment);
	}

	//*************************************************************************
	// every operation after this is scheduled, so make sure we have a schedule
	//*************************************************************************
	SYSTEM_SAFE2(sch, getSchedule(accept, comment), NULL);
	if (sch==NULL || !accept){
		RESPOND( accept, comment);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	if (!type.compare("STP")){
		sl = Utility::getMatches(re_stp,data,true);
		if (sl.size() != 4){
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		} else {
			size_t ref = strtoul(sl[3].c_str(),NULL,10);
			if (sch->cancelOperation(ref, comment)){
				RESPOND( true, "Operation " + data + " cancelled.");
			} else {
				RESPOND( false, comment);
			}
		}
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("FMT")){
		if (sch->getState() != SchIdle){
			RESPOND( false, "Not permitted while operations are scheduled or in progress");
		}
		// figure out which device this command refers to
		if (data.empty()){
			// default internal device
			SYSTEM_SAFE2(s_internal, getDefaultStorage(accept, comment), NULL);
		} else {
			if (data[0]=='/'){
				// external device, by device id
				SYSTEM_SAFE2(s_internal, getAlternateStorage(ST_EXTERNAL, "]"+data, accept, comment), NULL);
			} else {
				// internal device, by index
				SYSTEM_SAFE2(s_internal, getAlternateStorage(ST_INTERNAL, data, accept, comment), NULL);
			}
		}
		if (s_internal==NULL || !accept){
			RESPOND( false, "Unknown storage device '"+data+"'");
		}
		FormatOperation* op_fmt = new FormatOperation(received.getReference(), s_internal);
		checkAndSchedule(sch, op_fmt, accept, comment);
		RESPOND(accept,comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("SYN")){
		string altTimeAuthority = received.getMetaValue("AltTimeAuthority");
		if (altTimeAuthority.empty())
			altTimeAuthority = CONF_GET(TimeAuthority);
		SynchOperation* op_syn = new SynchOperation(received.getReference(), altTimeAuthority);
		checkAndSchedule(sch, op_syn, accept, comment);
		RESPOND(accept,comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("TST")){
		TestOperation* op_tst = new TestOperation(received.getReference(),strtoul(data.c_str(),NULL,10));
		checkAndSchedule(sch, op_tst, accept, comment);
		RESPOND(accept,comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("BUF")){



		string mt_enable       = received.getMetaValue("Enabled");
		string mt_period       = received.getMetaValue("Period");
		string mt_hold         = received.getMetaValue("Hold");
		string mt_auto_trigger = received.getMetaValue("AutoTrigger");
		string mt_vampire      = received.getMetaValue("Vampire");
		string mt_source       = received.getMetaValue("Source");

		string mt_receiver     = received.getMetaValue("Receiver");
		string mt_rate_limit   = received.getMetaValue("RateLimit");

		string mt_max_chunks_per_buf = received.getMetaValue("ChunksPerBuffer");
		string mt_buffer_limit = received.getMetaValue("BufferLimit");


		bool mt_enable_spec       = mt_enable.compare("");
		bool mt_period_spec       = mt_period.compare("");
		bool mt_hold_spec         = mt_hold.compare("");
		bool mt_auto_trigger_spec = mt_auto_trigger.compare("");
		bool mt_vampire_spec      = mt_vampire.compare("");
		//bool mt_source_spec       = mt_source.compare("");

		bool mt_receiver_spec     = mt_receiver.compare("");
		bool mt_rate_limit_spec   = mt_rate_limit.compare("");

		bool mt_max_chunks_per_buf_spec = mt_max_chunks_per_buf.compare("");
		bool mt_buffer_limit_spec = mt_buffer_limit.compare("");



		// group spec flags
		bool   mt_gr_capture  = (
			mt_enable_spec			||
			mt_period_spec     		||
			mt_hold_spec       		||
			mt_auto_trigger_spec	||
			mt_vampire_spec    	/*	||	mt_source_spec */
		);

		bool   mt_gr_receiver = (
			mt_receiver_spec			||
			mt_rate_limit_spec
		);

		bool   mt_gr_buffer   = (
			mt_max_chunks_per_buf_spec			||
			mt_buffer_limit_spec
		);

		bool   is_trigger = (!mt_gr_capture && !mt_gr_receiver && !mt_gr_buffer);


		if (	mt_gr_capture && ! (
					mt_enable_spec			&&
					mt_period_spec     		&&
					mt_hold_spec       		&&
					mt_auto_trigger_spec	&&
					mt_vampire_spec    	/* &&
					mt_source_spec */
				)){
			RESPOND( false, "Capture configuration metatag group member not supplied." );
		}

		if (	mt_gr_receiver && ! (
					mt_receiver_spec			&&
					mt_rate_limit_spec
				)){
			RESPOND( false, "Receiver configuration metatag group member not supplied." );
		}

		if (	mt_gr_buffer && ! (
					mt_max_chunks_per_buf_spec			&&
					mt_buffer_limit_spec
				)){
			RESPOND( false, "Buffer configuration metatag group member not supplied." );
		}

		LiveBuffer * lvb = System::get()->get_live_buffer();
		assert(lvb != NULL);

		if (is_trigger) {
			lvb->trigger_capture();
			RESPOND( true, "Capture triggered");
		} else {
			string msg = "Configured: ";
			if (mt_gr_receiver){
				IpSpec receiver_ip(mt_receiver);
				if (!receiver_ip.isIp() || !receiver_ip.isIpv4() || !receiver_ip.hasIp() || !receiver_ip.hasPort()){
					RESPOND( false, "Metatag value is invalid: 'Receiver' => '" + mt_receiver + "'" );
				}
				double _rate_limit   = (double) strtoul(mt_rate_limit.c_str(),NULL,10);
				string _ip           = receiver_ip.getIp();
				unsigned short _port = receiver_ip.getPort();
				lvb->configure_retrieval(_ip, _port, _rate_limit);
				msg += "receiver ";
			}

			if (mt_gr_capture){
				if (!(!mt_enable.compare("1") || !mt_enable.compare("0"))){
					RESPOND( false, "Metatag value is invalid: 'Enable' => '" + mt_enable + "'" );
				}
				if (!(!mt_auto_trigger.compare("1") || !mt_auto_trigger.compare("0"))){
					RESPOND( false, "Metatag value is invalid: 'AutoTrigger' => '" + mt_auto_trigger + "'" );
				}
				if (!(!mt_vampire.compare("1") || !mt_vampire.compare("0"))){
					RESPOND( false, "Metatag value is invalid: 'Vampire' => '" + mt_vampire + "'" );
				}

				bool   _enabled = (bool) strtoul(mt_enable.c_str(),NULL,10);
				size_t _period  = strtoul(mt_period.c_str(),NULL,10);
				size_t _hold    = strtoul(mt_hold.c_str(),NULL,10);
				bool   _auto    = (bool) strtoul(mt_auto_trigger.c_str(),NULL,10);
				bool   _vampire = (bool) strtoul(mt_vampire.c_str(),NULL,10);

				if (!_period){
					RESPOND( false, "Metatag value is invalid: 'Period' => '" + mt_period + "'" );
				}
				if (!_hold || (_hold > _period)){
					RESPOND( false, "Metatag value is invalid: 'Hold' => '" + mt_hold + "'" );
				}
				if (!_enabled){
					_period  = 0;
					_hold    = 0;
					_auto    = 0;
					_vampire = 0;
				}
				lvb->configure_capture(_period, _hold,_vampire,_auto);
				msg += "capture ";
			}

			if ( mt_gr_buffer ){
				size_t _max_chunks_per_buf = strtoul(mt_max_chunks_per_buf.c_str(),NULL,10);
				size_t _buffer_limit = strtoul(mt_buffer_limit.c_str(),NULL,10);
				if (!_buffer_limit){
					RESPOND( false, "Metatag value is invalid: 'BufferLimit' => '" + mt_buffer_limit + "'" );
				}
				if (!_max_chunks_per_buf){
					RESPOND( false, "Metatag value is invalid: 'ChunksPerBuffer' => '" + mt_max_chunks_per_buf + "'" );
				}

				lvb->configure_memory(_max_chunks_per_buf, _buffer_limit);
				msg += "buffers";
			}

			RESPOND( true, msg);
		}
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	//*************************************************************************
	// every operation after this requires internal storage
	//*************************************************************************

	string altInternalSpec = received.getMetaValue("DRSU");
	if (altInternalSpec.empty()){
		// default internal device
		SYSTEM_SAFE2(s_internal, getDefaultStorage(accept, comment), NULL);
		if (s_internal==NULL || !accept){
			RESPOND( false, comment);
		}
	} else {
		// alternative internal device
		SYSTEM_SAFE2(s_internal, getAlternateStorage(ST_INTERNAL, altInternalSpec, accept, comment), NULL);
		if (s_internal==NULL || !accept){
			RESPOND( false, "Unknown storage device '"+altInternalSpec+"' specified in metadata");
		}
	}

	string altInternalFileType = received.getMetaValue("TypeOverride");
	FileType typeOverride = FT_GENERAL;
	if (!altInternalFileType.empty()){
		LOGC(L_DEBUG, "[MessageProcessor] : TypeOverride specified '"+altInternalFileType+"'", ACTOR_COLORS);
		if (!altInternalFileType.compare("Recording") != 0){
			typeOverride = FT_GENERAL;
		} else if (!altInternalFileType.compare("Spectrometer")){
			typeOverride = FT_SPECTROMETER;
		}
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("GET")){
		if (sch->getState() != SchIdle){
			RESPOND( false, "Not permitted while operations are scheduled or in progress");
		}
		sl = Utility::getMatches(re_get,data);
		if (sl.size() != 6){
			int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		}
		string tag = sl[1];
		size_t offset = strtoul(sl[4].c_str(),NULL,10);
		size_t size   = strtoul(sl[5].c_str(),NULL,10);
		if (size > RFS_DATA){
			RESPOND( false, "Requested length exceeds response size");
		}
		openIn(s_internal, typeOverride, tag, tagfile, accept,comment);
		if (!accept){
			RESPOND( accept, comment);
		}

		size_t fsize = tagfile->getSize();
		if (offset + size > fsize){
			RESPOND( false, "Request exceeds file size '"+tag+"'");
		}
		char buf[RFS_DATA];
		volatile int* fd = tagfile->getDescriptor();

		if ((size_t) lseek(*fd,offset,SEEK_SET) != offset){
			RESPOND( false, "Program error: Can't seek to offset in file '"+tag+"'");
		}
		if ((size_t) read(*fd,buf,size) != size){
			RESPOND( false, "Program error: Read fewer bytes than requested for file '"+tag+"'");
		}
		s_internal->putFile(tagfile);
		ResponseSender::respondBinary(received,true,buf,size);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

//	if (!type.compare("REC") && !Utility::reMatch(re_rec_s,data)){
	if (!type.compare("REC")){
		//LOGC(L_FATAL,"--- SCHEDULER 0 ---", FATAL_COLORS);
		sl = Utility::getMatches(re_rec_n,data);
		if (sl.size() != 5){
			int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		}
		size_t      startMJD   = strtoul(sl[1].c_str(),NULL,10);
		size_t      startMPM   = strtoul(sl[2].c_str(),NULL,10);
		millisecond duration   = strtoul(sl[3].c_str(),NULL,10);
		string      formatName = sl[4];
		TimeSlot ts(__TimeStamp(startMJD, startMPM),duration);
		ScheduledOperation* conflict;
		//LOGC(L_FATAL,"--- SCHEDULER 1 ---", FATAL_COLORS);
		if (!sch->isTimeSlotFree(ts, conflict)){
			if (conflict != NULL){
				RESPOND( false,  "Operation not scheduled due to time conflict with " + conflict->toString());
			} else {
				RESPOND( false, "Operation not scheduled due to bad pointer");
			}
		}

		//LOGC(L_FATAL,"--- SCHEDULER 2 ---", FATAL_COLORS);

		if (!DataFormat::isFormatNameKnown(formatName)){
			RESPOND( false, "Unknown data format '"+formatName+"'");
		}
		DataFormat opFormat = DataFormat::getFormatByName(formatName);
		char optag[20];
		sprintf(optag, "%.6lu_%.9lu", startMJD, received.getReference());
		string tag(optag);
		size_t size        = opFormat.estimateDataVolume(duration, 5.0);

		if (size > s_internal->getFreespace()){
			RESPOND( false, "Insufficient free drive space on '"+s_internal->getVolumeName()+"'");
		}

		TicketBuffer* buf;
		SYSTEM_SAFE2(buf, getRxBuf(), NULL);
		if (!buf){
			RESPOND( false, "Subsystem unavailable: 'Receive buffer'");
		}

		openOut(s_internal, typeOverride, tag, tagfile, 0, accept,comment);
		if (!accept){
			RESPOND( false, "Cannot create output file, or file already exists");
		}
		bool doSidCheck = false;
		string doSidCheckString = received.getMetaValue("doSidCheck");
		if (!doSidCheckString.empty()){
			doSidCheck = ! doSidCheckString.compare("yes");
		}

		//LOGC(L_FATAL,"--- SCHEDULER 3 ---", FATAL_COLORS);
		RecordOperation* op_rec = new RecordOperation(received.getReference(),ts,buf,opFormat,tagfile,size, doSidCheck);
		//LOGC(L_FATAL,"--- SCHEDULER 4 ---", FATAL_COLORS);
		checkAndSchedule(sch, op_rec, accept, comment);
		//LOGC(L_FATAL,"--- SCHEDULER 5 ---", FATAL_COLORS);
		if (!accept){
			s_internal->putFile(tagfile);
			RESPOND(accept,comment);
		} else {
			RESPOND(accept,tag);
		}
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
/*	if (
			(!type.compare("REC") && Utility::reMatch(re_rec_s,data)) ||
			(!type.compare("SPC"))
	){

		size_t      DEBUG_SPC = 0;
		LOGC(L_DEBUG, "DEBUG_SPC: @" + LXS(DEBUG_SPC++), TRACE_COLORS);
		size_t      startMJD;
		size_t      startMPM;
		millisecond duration;
		string      __attribute__ ((unused)) formatName; // ignored
		size_t      Nfreqs;
		size_t      NInts;
		size_t     __attribute__ ((unused)) minfill; // ignored
		size_t     __attribute__ ((unused)) highwater; // ignored


		//*************************************************************************
		// parse differs dep. on whether REC syntax of SPC syntax
		//*************************************************************************
		if (!type.compare("SPC")){
			// parse as normal spc command
			sl = Utility::getMatches(re_spc,data);
			if (sl.size() < 6){
				int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
				RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
			}
			startMJD   = strtoul(sl[1].c_str(),NULL,10);
			startMPM   = strtoul(sl[2].c_str(),NULL,10);
			duration   = strtoul(sl[3].c_str(),NULL,10);
			Nfreqs     = strtoul(sl[4].c_str(),NULL,10);
			NInts      = strtoul(sl[5].c_str(),NULL,10);
			if (sl.size() >= 7)
			minfill    = strtoul(sl[6].c_str(),NULL,10); // ignored
			if (sl.size() >= 8)
			highwater  = strtoul(sl[7].c_str(),NULL,10); // ignored

		} else {
			// parse as REC variant
			sl = Utility::getMatches(re_rec_s,data);
			if (sl.size() < 7){
				int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
				RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
			}
			startMJD   = strtoul(sl[1].c_str(),NULL,10);
			startMPM   = strtoul(sl[2].c_str(),NULL,10);
			duration   = strtoul(sl[3].c_str(),NULL,10);
			formatName = sl[4];
			Nfreqs     = strtoul(sl[5].c_str(),NULL,10);
			NInts      = strtoul(sl[6].c_str(),NULL,10);
			if (sl.size() >= 8)
			minfill    = strtoul(sl[7].c_str(),NULL,10); // ignored
			if (sl.size() >= 9)
			highwater  = strtoul(sl[8].c_str(),NULL,10); // ignored
		}


		string stokesModeString = received.getMetaValue("Stokes");
		if (stokesModeString.empty()){
			stokesModeString = "XXYY";
		}

		StokesProduct outputType = nameToStokes(stokesModeString);
		if (outputType == INVALID_STOKES){
			RESPOND( false, "Unknown Stokes output type '"+stokesModeString+"'");
		}

		if (!StokesSupported(outputType)){
			RESPOND( false, "Unsupported Stokes output type '"+stokesModeString+"'");
		}

		if ((Nfreqs > 16384) || (Nfreqs<32)){
			RESPOND( false, "Unsupported channel count: '"+LXS(Nfreqs)+"'");
		}

		if ((NInts > 24576) || (NInts<384)){
			RESPOND( false, "Unsupported integration count: '"+LXS(NInts)+"'");
		}

		if (((Nfreqs*NInts)%DRX_SAMPLES_PER_FRAME) != 0){
			RESPOND( false, "Unsupported geometry: 'Nf x Ni  must be an integral multiple of DRX frame sizes'");
		}

		TimeSlot ts(__TimeStamp(startMJD, startMPM),duration);

		ScheduledOperation* conflict;
		if (!sch->isTimeSlotFree(ts, conflict)){
			if (conflict != NULL){
				RESPOND( false,  "Operation not scheduled due to time conflict with " + conflict->toString());
			} else {
				RESPOND( false, "Operation not scheduled due to bad pointer");
			}
		}

		DataFormat opFormat=DataFormat::getFormatByName("DEFAULT_DRX");

		char optag[20];
		sprintf(optag, "%.6lu_%.9lu", startMJD, received.getReference());
		string tag(optag);

		TicketBuffer* buf;
		SYSTEM_SAFE2(buf, getRxBuf(), NULL);
		if (!buf){
			RESPOND( false, "Subsystem unavailable: 'Receive buffer'");
		}

		openOut(s_internal, FT_SPECTROMETER, tag, tagfile, 0, accept,comment);
		if (!accept){
			RESPOND( false, "Cannot create output file, or file already exists");
		}

		SpectrometerOperation* op_spc = new SpectrometerOperation(received.getReference(),ts,buf,opFormat,tagfile,0, outputType,Nfreqs, NInts);
		checkAndSchedule(sch, op_spc, accept, comment);
		if (!accept){
			s_internal->putFile(tagfile);
			RESPOND(accept,comment);
		} else {
			RESPOND(accept,tag);
		}

	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	//*************************************************************************
	// parse possible alternate external specifier
	//*************************************************************************

	string altExternalSpec = received.getMetaValue("External");
	bool haveAltExternal = false;
	if (!altExternalSpec.empty()){
		// alternative internal device
		SYSTEM_SAFE2(s_external, getAlternateStorage(ST_EXTERNAL, altExternalSpec, accept, comment), NULL);
		if (s_external==NULL || !accept){
			RESPOND( false, "Unknown storage device '"+altExternalSpec+"' specified in metadata");
		}
		haveAltExternal = true;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("CPY")){
		if (sch->getState() != SchIdle){
			RESPOND( false, "Not permitted while operations are scheduled or in progress");
		}
		sl = Utility::getMatches(re_cpy,data);
		if (sl.size() != 8){
			int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		}
		string tag = sl[1];
		size_t offset      = strtoul(sl[4].c_str(),NULL,10);
		size_t size        = strtoul(sl[5].c_str(),NULL,10);
		string extDevId    = sl[6];
		string extFileName = sl[7];

		openIn(s_internal, typeOverride, tag, tagfile, accept,comment);
		if (!accept){
			RESPOND( accept, comment);
		}

		size_t fsize = tagfile->getSize();
		if (offset + size > fsize){
			s_internal->putFile(tagfile);
			RESPOND( false, "Request exceeds file size '"+tag+"'");
		}

		if (!haveAltExternal){
			SYSTEM_SAFE2(s_external, getAlternateStorage(ST_EXTERNAL, "]"+extDevId, accept, comment), NULL);
			if (s_external==NULL || !accept){
				s_internal->putFile(tagfile);
				RESPOND( false, "Unknown storage device '"+extDevId+"' specified in metadata");
			}
		}
		if (size > s_external->getFreespace()){
			s_internal->putFile(tagfile);
			RESPOND( false, "Insufficient free drive space on '"+s_external->getVolumeName()+"'");
		}

		openOut(s_external, FT_GENERAL, extFileName, extfile, size, accept,comment);
		if (!accept){
			s_internal->putFile(tagfile);
			RESPOND( accept, comment);
		}

		CopyOperation* op_cpy = new CopyOperation(received.getReference(), s_internal, s_external, tagfile, extfile, offset, size, (haveAltExternal ? altExternalSpec : extDevId) );
		checkAndSchedule(sch, op_cpy, accept, comment);
		if (!accept){
			s_external->putFile(extfile);
			s_internal->putFile(tagfile);
		}
		RESPOND(accept,comment);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (!type.compare("DMP")){
		if (sch->getState() != SchIdle){
			RESPOND( false, "Not permitted while operations are scheduled or in progress");
		}
		sl = Utility::getMatches(re_dmp,data);
		if (sl.size() != 9){
			int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		}
		string tag = sl[1];
		size_t offset      = strtoul(sl[4].c_str(),NULL,10);
		size_t size        = strtoul(sl[5].c_str(),NULL,10);
		size_t chunkSize   = strtoul(sl[6].c_str(),NULL,10);
		string extDevId    = sl[7];
		string extFileName = sl[8];

		openIn(s_internal, typeOverride, tag, tagfile, accept,comment);
		if (!accept){
			RESPOND( accept, comment);
		}

		size_t fsize = tagfile->getSize();
		if (offset + size > fsize){
			s_internal->putFile(tagfile);
			RESPOND( false, "Request exceeds file size '"+tag+"'");
		}

		if (!haveAltExternal){
			SYSTEM_SAFE2(s_external, getAlternateStorage(ST_EXTERNAL, "]"+extDevId, accept, comment), NULL);
			if (s_external==NULL || !accept){
				s_internal->putFile(tagfile);
				RESPOND( false, "Unknown storage device '"+extDevId+"' specified in metadata");
			}
		}

		if (size > s_external->getFreespace()){
			s_internal->putFile(tagfile);
			RESPOND( false, "Insufficient free drive space on '"+s_external->getVolumeName()+"'");
		}

		size_t numChunks = size/chunkSize;
		if ((numChunks*chunkSize) != size){
			numChunks++;
		}
		size_t curChunk=0;
		size_t thisChunkSize;
		int digits = LXS(numChunks).size();

		//LOGC(L_DEBUG, "NumChunks " + LXS(numChunks), FATAL_COLORS);

		for(; curChunk<numChunks; curChunk++){
			char name_buf[1024];
			thisChunkSize = (curChunk != (numChunks-1)) ? chunkSize: (size-((numChunks-1) * chunkSize));
			snprintf(name_buf,1023,"%s.%.*lu", extFileName.c_str(), digits, curChunk);
			string curExtFileName = string(name_buf);
			openOut(s_external, FT_GENERAL, curExtFileName, extfile, thisChunkSize, accept,comment);
			if (!accept){
				s_internal->putFile(tagfile);
				if (extfile){
					if (extfile->isOpen()) extfile->close();
					extfile->remove();
					s_external->putFile(extfile);
				}
				while(!extfiles.empty()){
					extfile = extfiles.front(); extfiles.pop_front();
					if (extfile){
						if (extfile->isOpen()) extfile->close();
						extfile->remove();
						s_external->putFile(extfile);
					}
				}
				RESPOND( accept, comment);
			} else {
				LOGC(L_DEBUG, "Created file '"+curExtFileName+"' of size " + Storage::humanReadable(thisChunkSize), ACTOR_COLORS);
				extfiles.push_back(extfile);
				extfile = NULL;
			}
		}

		DumpOperation* op_dmp = new DumpOperation(received.getReference(), s_internal, s_external, tagfile, extfiles, offset, size, chunkSize, (haveAltExternal ? altExternalSpec : extDevId) );
		checkAndSchedule(sch, op_dmp, accept, comment);
		if (!accept){
			s_internal->putFile(tagfile);
			while(!extfiles.empty()){
				extfile = extfiles.front(); extfiles.pop_front();
				if (extfile){
					if (extfile->isOpen()) extfile->close();
					extfile->remove();
					s_external->putFile(extfile);
				}
			}
			RESPOND(accept,comment);
		}
		RESPOND(accept,comment);
	}


	if (!type.compare("DEL")){
		if (sch->getState() != SchIdle){
			RESPOND( false, "Not permitted while operations are scheduled or in progress");
		}
		sl = Utility::getMatches(re_del,data);
		if (sl.size() != 4){
			int i=0;foreach(string s, sl){LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);}
			RESPOND( false, "Bad format: bad argument count ("+LXS(sl.size())+")");
		}
		string tag = sl[1];
		tagfile = s_internal->getQueryFile(typeOverride, tag);
		if (tagfile == NULL || !tagfile->exists()){
			RESPOND( false, "Unknown tag file '"+tag+"'");
		}

		string fullpath = tagfile->getFullPath();
		s_internal->putFile(tagfile);
		DeleteOperation* op_del = new DeleteOperation(received.getReference(),fullpath, tag);
		checkAndSchedule(sch, op_del, accept, comment);
		RESPOND(accept,comment);
	}

	if (!type.compare("SRP")){
		Storage::reportAll();
		RESPOND(true,"");
	}



	RESPOND( false, "Invalid command");

	//LOGC(L_INFO, "["+this->getName()+"] onDoReceive() done.",bold,black, red);

	return false;
}

MessageProcessor::~MessageProcessor(){

}


StringList MessageProcessor::commandNames = list_of
		("SRP")
		("SHT")("INI")("EXT")("PNG")("ECH") // instants
		("SEL")("DVN")("STP")("GET")        // shortrun
		(" UP")("UP ")("UP")("DWN")("TST")  // longrun
		("SYN")
		("FMT")("DEL")
		("CPY")
		("DMP")
		("REC")
		("BUF")



		("RPT")// shortrun
		/*("SPC")*/ // operations
		;

///////////////////////////
// some helper functions
///////////////////////////


// generic regular expressions for word parts
const string MessageProcessor::re_match_nothing = "a^";
const string MessageProcessor::re_int         ="[0-9]";
const string MessageProcessor::re_ws            = "(?:\\s+)";
const string MessageProcessor::re_w_mjd       = "\\s*(" + re_int + __rem(1,6) + ")";
const string MessageProcessor::re_w_mpm       = "\\s*(" + re_int + __rem(1,9) + ")";
const string MessageProcessor::re_w_tag       = "(" + re_w_mjd  + "_" + re_w_mpm + ")";
const string MessageProcessor::re_w_ms_dur    = "(" + re_int + __rem(1,9) + ")";
const string MessageProcessor::re_w_fftl      = "(" + re_int + __rem(1,6) + ")";
const string MessageProcessor::re_w_intcnt    = "(" + re_int + __rem(1,8) + ")";
const string MessageProcessor::re_w_minfill   = re_w_intcnt;
const string MessageProcessor::re_w_hiwater   = "(" + re_int + __rem(1,4) + ")";
const string MessageProcessor::re_w_size      = "(" + re_int + __rem(1,16) + ")";
const string MessageProcessor::re_w_dev       = "(/dev/(?:(?:[hms]d)[a-zA-Z]+(?:[0-9]*)))";
const string MessageProcessor::re_w_filechars = "(?:[a-zA-Z0-9~@#%\\^\\-_\\{\\}\\[\\],\\.]|(?:\\\\ ))";
const string MessageProcessor::re_w_namepart  = "(?:" + re_w_filechars + __rem(1,255) + ")";
const string MessageProcessor::re_w_dirsep    = "(?:\\/*)";
const string MessageProcessor::re_w_filepart  = "(?:" +re_w_namepart+"|"+re_w_dirsep+ ")";
const string MessageProcessor::re_w_file      = "("+re_w_filepart+"+)";
const string MessageProcessor::re_empty       = "(?:^$)";
const string MessageProcessor::re_w_barcode   =	"([^,=]{1,16})";
const string MessageProcessor::re_w_fmt_name  = "([A-Za-z_][A-Za-z_0-9]*)";

// regular expressions for commands
const string MessageProcessor::re_png   = re_empty;
const string MessageProcessor::re_ext   = re_empty;
const string MessageProcessor::re_sht   = "((SCRAM)|(RESTART)|\\s)*";
const string MessageProcessor::re_ech   = "(ON|OFF)?";
const string MessageProcessor::re_ini 	= "((--flush-log)|(-L)|(--flush-data)|(-D)|\\s*)*";
const string MessageProcessor::re_del 	= re_w_tag;
const string MessageProcessor::re_stp 	= re_w_tag;
const string MessageProcessor::re_get 	= re_w_tag + re_ws + re_w_size + re_ws + re_w_size;
const string MessageProcessor::re_cpy 	= re_get + re_ws + re_w_dev + re_ws + re_w_file;
const string MessageProcessor::re_dmp 	= re_get + re_ws + re_w_size + re_ws + re_w_dev + re_ws + re_w_file;
const string MessageProcessor::re_fmt 	= "(?:" + re_empty + "|" +re_w_dev+ ")";
const string MessageProcessor::re_up  	= re_empty;
const string MessageProcessor::re_dwn 	= re_empty;
const string MessageProcessor::re_sel 	= "(?:(?:\\d{1,2})|(?:[\\)\\]\\}]"+re_w_barcode+"))";
const string MessageProcessor::re_svn 	= re_w_barcode;
const string MessageProcessor::re_buf   = re_empty;

/*
 * old form; deprecated
const string MessageProcessor::re_buf 	= "(([TI])([TI])([AN])([AB])([DHR]))" + re_ws + re_w_size + re_ws + re_w_size + re_ws + re_w_size;
*/
const string MessageProcessor::re_syn 	 = re_empty;
//const string MessageProcessor::re_spc 	= re_w_mjd + re_ws + re_w_mpm + re_ws + re_w_ms_dur + re_ws + re_w_fftl + re_ws + re_w_intcnt + __opt(re_ws + re_w_minfill +__opt(re_ws + re_w_hiwater ));
const string MessageProcessor::re_rec_n  = re_w_mjd + re_ws + re_w_mpm + re_ws + re_w_ms_dur + re_ws + re_w_fmt_name;
//const string MessageProcessor::re_rec_s = re_w_mjd + re_ws + re_w_mpm + re_ws + re_w_ms_dur + re_ws + re_w_fmt_name + re_w_fftl + re_ws + re_w_intcnt + __opt(re_ws + re_w_minfill +__opt(re_ws + re_w_hiwater ));
//const string MessageProcessor::re_rec   = __or(re_rec_n, re_rec_s);
const string MessageProcessor::re_rec    = re_rec_n;
const string MessageProcessor::re_tst    = ".*";
const string MessageProcessor::re_srp 	  = re_empty;


// regular expressions for mib entries
/*
const string MessageProcessor::re_rpt   =
		"("
		"(OP-(TYPE|SCHEDULE|START|STOP|REFERENCE|TAG|FORMAT|POSITION|FILENAME|FILEINDEX))"  "|"
		"(SCHEDULE-((COUNT)|(ENTRY-([0-9]+))))"                                             "|"
		"(DIRECTORY-((COUNT)|(ENTRY-(-?[0-9]+))))"                                          "|"
		"(((TOTAL)|(REMAINING)|(CONTIGUOUS))-STORAGE)"                                      "|"
		"(DEVICE-((COUNT)|(ID-([0-9]+))|(STORAGE-([0-9]+))))"                               "|"
		"(CPU-((COUNT)|(TEMP-([0-9]+))))"                                                   "|"
		"(HDD-((COUNT)|(TEMP-([0-9]+))))"                                                   "|"
		"(FORMAT-((COUNT)|(NAME-([0-9]+))|(PAYLOAD-([0-9]+))|(RATE-([0-9]+))))"             "|"
		"(LOG-((COUNT)|(ENTRY-(-?[0-9]+))))"                                                "|"
		"(BUFFER(-RESTRICT)?)"                                                              "|"
		"(DRSU-((COUNT)|(SELECTED)|(BARCODE)|(INFO-([0-9]+))))"                             "|"
		"(TT-LAG(-INITIAL)?)"
		")";
*/
INIT_ACCESS_MUTEX_ST(MessageProcessor);

bool MessageProcessor::isCommand(string type){
	SERIALIZE_ACCESS_ST();
	foreach(string toCompare, commandNames){
		if (!toCompare.compare(type))
			return true;
	}
	return false;
}

string MessageProcessor::getCommandFormatRegEx(string type){
	SERIALIZE_ACCESS_ST();
	if (!type.compare("PNG")) return re_png;
	if (!type.compare("RPT")) return re_rpt;
	if (!type.compare("SHT")) return re_sht;
	if (!type.compare("EXT")) return re_ext;
	if (!type.compare("INI")) return re_ini;
	if (!type.compare("STP")) return re_stp;
	if (!type.compare("SYN")) return re_syn;
	if (!type.compare("REC")) return re_rec;
	//if (!type.compare("SPC")) return re_spc;
	if (!type.compare("GET")) return re_get;
	if (!type.compare("CPY")) return re_cpy;
	if (!type.compare("DMP")) return re_dmp;
	if (!type.compare("DEL")) return re_del;
	if (!type.compare("SEL")) return re_sel;
	if (!type.compare("UP" )) return re_up;
	if (!type.compare(" UP" )) return re_up;
	if (!type.compare("UP " )) return re_up;
	if (!type.compare("DWN")) return re_dwn;
	if (!type.compare("FMT")) return re_fmt;
	if (!type.compare("DVN")) return re_svn;
	if (!type.compare("ECH")) return re_ech;
	if (!type.compare("TST")) return re_tst;
	if (!type.compare("SRP")) return re_srp;
	if (!type.compare("BUF")) return re_buf;


	return re_match_nothing;
}



bool MessageProcessor::isProperlyFormatted(string type, string data){
	SERIALIZE_ACCESS_ST();
	return  Utility::reMatch(getCommandFormatRegEx(type),data);
}

StringList MessageProcessor::parseCommandRegex(string type, string data){
	SERIALIZE_ACCESS_ST();
	return  Utility::getMatches(getCommandFormatRegEx(type),data,false);
}


const string MessageProcessor::re_rpt   =
		"(?:"
		"(?:(SUMMARY)|(INFO)|(LASTLOG)|(SUBSYSTEM)|(SERIALNO)|(VERSION))"                         "|"
		"(?:(OP)-(TYPE|SCHEDULE|START|STOP|REFERENCE|TAG|FORMAT|POSITION|FILENAME|FILEINDEX))"    "|"
		"(?:(SCHEDULE)-(?:(COUNT)|(?:(ENTRY)-([0-9]+))))"                                         "|"
		"(?:(DIRECTORY)-(?:(COUNT)|(?:(ENTRY)-(-?[0-9]+))))"                                      "|"
		"(?:(?:(TOTAL)|(REMAINING)|(CONTIGUOUS))-(STORAGE))"                                      "|"
		"(?:(DEVICE)-(?:(COUNT)|(?:(BARCODE)-([0-9]+))|(?:(ID)-([0-9]+))|(?:(STORAGE)-([0-9]+))))"                       "|"
		"(?:(CPU)-(?:(COUNT)|(?:(TEMP)-([0-9]+))))"                                               "|"
		"(?:(HDD)-(?:(COUNT)|(?:(TEMP)-([0-9]+))))"                                               "|"
		"(?:(FORMAT)-(?:(COUNT)|(?:(NAME)-([0-9]+))|(?:(PAYLOAD)-([0-9]+))|(?:(RATE)-([0-9]+))))" "|"
		"(?:(LOG)-(?:(COUNT)|(?:(ENTRY)-(-?[0-9]+))))"                                            "|"
		"(?:(BUFFER)(?:-(RESTRICT))?)"                                                            "|"
		"(?:(DRSU)-(?:(COUNT)|(SELECTED)|(BARCODE)|(?:(INFO)-([0-9]+))))"                         "|"
		"(?:(TT-LAG)(?:-(INITIAL))?)"
		")";




#define strEqual(s1,s2) (!s1.compare(s2))
#define isGroup(s)    (strEqual(sl[1],s))
#define isSubGroup(s) ((sl.size()>=3) && (strEqual(sl[2],s)))
#define isMibBasic(s) (strEqual(data,s))
#define getIndexOn(sIdx) \
	size_t idx = 0;\
	if (sl.size()<=sIdx){\
		UNKNOWN();\
	}else{\
		idx = strtoul(sl[sIdx].c_str(),NULL,10);\
	}

#define getSignedIndexOn(sIdx)\
	ssize_t sidx = 0;\
	if (sl.size()<=sIdx){\
		UNKNOWN();\
	}else{\
		sidx = strtol(sl[sIdx].c_str(),NULL,10);\
	}

#define MIB_RESPOND(a,c) accept=a; comment=c; return
#define UNKNOWN() MIB_RESPOND(false,"Unknown MIB entry: '"+data+"'")
#define getSchedule() \
		Schedule* sch=NULL;\
		SYSTEM_SAFE2(sch, getSchedule(accept, comment), NULL);\
		if (sch==NULL || !accept){\
			return;\
		}

#define MIB_GET_STORAGE()\
		string stype = received.getMetaValue("StorageOverride");\
		string sspec = received.getMetaValue("DRSU");\
		StorageType st = ST_INTERNAL;\
		FileType __attribute__ ((unused)) ft    = FT_GENERAL;\
		if (strEqual(stype,"Spectrometer")){\
			LOGC(L_DEBUG,"STO: Spectrometer", MESSAGING_ERROR_COLORS);\
			ft = FT_SPECTROMETER;\
		} else if (strEqual(stype,"External")){\
			LOGC(L_DEBUG,"STO: External", MESSAGING_ERROR_COLORS);\
			ft = FT_GENERAL;\
			st = ST_EXTERNAL;\
			sspec = received.getMetaValue("External");\
		} else {\
			LOGC(L_DEBUG,"STO: Default", MESSAGING_ERROR_COLORS);\
		}\
		Storage* sto;\
		if (st == ST_INTERNAL){\
			if (sspec.empty()){\
				/* default internal device */\
				SYSTEM_SAFE2(sto, getDefaultStorage(accept, comment), NULL);\
			} else {\
				/* alternative internal device */\
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_INTERNAL, sspec, accept, comment), NULL);\
			}\
		} else {\
			if (sspec.empty()){\
				MIB_RESPOND(false,"You must supply an external device storage specification");\
			} else {\
				/* alternative internal device */\
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_EXTERNAL, sspec, accept, comment), NULL);\
			}\
		}\
		if (sto==NULL || !accept){\
			MIB_RESPOND(false,"Unknown storage device '"+sspec+"' specified in metadata");\
		}\


void MessageProcessor::getMib(Message& received, bool& accept, string& comment){

	string data = received.getData();

	// MIB basics
	if (isMibBasic("SUMMARY")){
		string val="";
		SYSTEM_SAFE2(val, getCurrentStatus(), "");
		if (val.empty()){
			MIB_RESPOND(false, "Program error: invalid program state");
		} else {
			MIB_RESPOND(true,  val);
		}
	} else if isMibBasic("INFO") {
		string val="";
		SYSTEM_SAFE2(val, getInfo(), "");
		if (val.empty()){
			MIB_RESPOND(false, "Program error: invalid program state");
		} else {
			MIB_RESPOND(true,  val);
		}
	} else if isMibBasic("LASTLOG") {
		string val=Log::lastLog();
		MIB_RESPOND(true,  val);
	} else if isMibBasic("SUBSYSTEM") {
		string val=CONF_GET(MyReferenceDesignator);
		MIB_RESPOND(true,  val);
	} else if isMibBasic("SERIALNO") {
		string val=CONF_GET(SerialNumber);
		MIB_RESPOND(true,  val);
	} else if isMibBasic("VERSION") {
		string val="";
		SYSTEM_SAFE2(val, getVersion(), "");
		if (val.empty()){
			MIB_RESPOND(false, "Program error: invalid program state");
		} else {
			MIB_RESPOND(true,  val);
		}
	} else {
		// extract group, subgroup, etc.
		StringList sl = Utility::getMatches(re_rpt,data,true);
		if (sl.size()<2){
			UNKNOWN();
		}

		// storage group is wierd
		if ((sl.size()>=3) && strEqual(sl[2],"STORAGE") && !strEqual(sl[1],"DEVICE")){
			sl[1].swap(sl[2]);
		}

		// DROS-specific MIB
		if isGroup("OP") {
			getSchedule();
			Operation* curOp = sch->getCurrentOperation();
			if (curOp == NULL){
				MIB_RESPOND(false,"Internal error: no current operation or scheduler unavailable");
			}
			if isSubGroup("TYPE") {
				MIB_RESPOND(true, curOp->getOpType());
			} else if isSubGroup("SCHEDULE") {
				MIB_RESPOND(true, curOp->getOpStart() + " " + curOp->getOpStop());
			} else if isSubGroup("START") {
				MIB_RESPOND(true, curOp->getOpStart());
			} else if isSubGroup("STOP") {
				MIB_RESPOND(true, curOp->getOpStop());
			} else if isSubGroup("REFERENCE") {
				MIB_RESPOND(true, curOp->getOpReference());
			} else if isSubGroup("TAG") {
				MIB_RESPOND(true, curOp->getOpTag());
			} else if isSubGroup("FORMAT") {
				MIB_RESPOND(true, curOp->getOpFormat());
			} else if isSubGroup("POSITION") {
				MIB_RESPOND(true, curOp->getOpFilePos());
			} else if isSubGroup("FILENAME") {
				MIB_RESPOND(true, curOp->getOpFileName());
			} else if isSubGroup("FILEINDEX") {
				MIB_RESPOND(true, curOp->getOpFileIndex());
			}
		} else if isGroup("SCHEDULE") {
			getSchedule();
			if isSubGroup("COUNT") {
				MIB_RESPOND(true, LXS(sch->getScheduleEntryCount()));
			} else if isSubGroup("ENTRY") {
				getIndexOn(3);


				bool doFull = !received.getMetaValue("ShowLongForm").compare("yes");
				string se = sch->getScheduleEntry((int)idx,doFull);
				//LOGC(L_DEBUG, "<< index  >> "+ LXS(idx), MESSAGING_ERROR_COLORS);
				//LOGC(L_DEBUG, "<< doFull >> "+ string(doFull ? "true" : "false"), MESSAGING_ERROR_COLORS);
				//LOGC(L_DEBUG, "<< se     >> "+ se, MESSAGING_ERROR_COLORS);
				if (se.empty()){
					UNKNOWN();
				} else {
					MIB_RESPOND(true,se);
				}
			}
		} else if isGroup("DIRECTORY") {
			MIB_GET_STORAGE();
			LOGC(L_DEBUG, "File type:           "+ fileTypeString(ft), MESSAGING_ERROR_COLORS);
			LOGC(L_DEBUG, "Storage mount point: "+ sto->getMountPoint(), MESSAGING_ERROR_COLORS);
			LOGC(L_DEBUG, "Storage type:        "+ storageTypeString(sto->getStorageType()), MESSAGING_ERROR_COLORS);
			int k=sto->getFileCount(ft);

			if (k<0){
				MIB_RESPOND(false,"Specified filetype '"+fileTypeString(ft)+"' is not valid for this storage class '" + storageTypeString(sto->getStorageType())+"'");
			}

			if isSubGroup("COUNT") {
				MIB_RESPOND(true, LXS(k));
			} else if isSubGroup("ENTRY") {
				getSignedIndexOn(3);
				if (!sidx){
					LOGC(L_DEBUG,"Bad index "+LXS(sidx), MESSAGING_ERROR_COLORS);
					UNKNOWN();
				}
				File* file = (sidx > 0) ? sto->getQueryFile(ft,sidx-1) : sto->getQueryFile(ft,sidx);
				if (!file){
					LOGC(L_DEBUG,"No such file "+LXS(sidx)+" of type " + fileTypeString(ft), MESSAGING_ERROR_COLORS);
					UNKNOWN();
				}

				size_t sz       = file->getSize();
				size_t sza      = file->getAllocatedSize();
				string format   = file->getAttribute("opFormat");
				string start    = file->getAttribute("opStart");
				string stop     = file->getAttribute("opStop");
				string tag      = file->getAttribute("opTag");
				string complete = file->getAttribute("opComplete");

				LOGC(L_DEBUG,"File tag:           '" + tag      + "'", MESSAGING_COLORS);
				LOGC(L_DEBUG,"File size:          "  + LXS(sz),        MESSAGING_COLORS);
				LOGC(L_DEBUG,"File size (alloc):  "  + LXS(sza),       MESSAGING_COLORS);
				LOGC(L_DEBUG,"File format:        '" + format   + "'", MESSAGING_COLORS);
				LOGC(L_DEBUG,"File start:         '" + start    + "'", MESSAGING_COLORS);
				LOGC(L_DEBUG,"File stop:          '" + stop     + "'", MESSAGING_COLORS);
				LOGC(L_DEBUG,"File complete:      '" + complete + "'", MESSAGING_COLORS);
				sto->putFile(file);


				char buf[8192];
				memset(buf, ' ', 8192);
				snprintf(buf,8192,"%-16.16s %-17.17s %-17.17s %-32.32s %.15lu %.15lu %-3.3s",
					tag.c_str(),
					start.c_str(),
					stop.c_str(),
					format.c_str(),
					sz,
					sza,
					complete.c_str()
				);
				MIB_RESPOND(true, string(buf));
			}
		} else if isGroup("STORAGE") {
			MIB_GET_STORAGE();
			if isSubGroup("TOTAL") {
				MIB_RESPOND(true, LXS(sto->getSize()));
			} else if isSubGroup("REMAINING") {
				MIB_RESPOND(true, LXS(sto->getFreespace()));
			} else if isSubGroup("CONTIGUOUS") {
				MIB_RESPOND(false, "0; <MIB-ENTRY DEPRECATED>");
			}
		} else if isGroup("DEVICE") {
			size_t ext_count = Storage::getDeviceCount(ST_EXTERNAL);
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(ext_count));
			} else{
				getIndexOn(3);
				if ((idx <1)||(idx>ext_count)){
					UNKNOWN();
				}
				Storage* sto;
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_EXTERNAL, LXS(idx), accept, comment), NULL);
				if (sto==NULL || !accept){
					UNKNOWN();
				}
				if isSubGroup("ID") {
					MIB_RESPOND(true,sto->getPartition());
				} else if isSubGroup("STORAGE") {
					MIB_RESPOND(true,LXS(sto->getSize()));
				} else if isSubGroup("BARCODE") {
					MIB_RESPOND(true,LXS(sto->getVolumeName()));
				} else if isSubGroup("REMAINING") {
					MIB_RESPOND(true,LXS(sto->getFreespace()));
				}
			}
		} else if isGroup("CPU") {
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(CpuInfo::getCpuCount()));
			} else if isSubGroup("TEMP") {
				getIndexOn(3);
				if (!idx){	UNKNOWN(); }
				float temp = CpuInfo::getCpuTemp(idx-1);
				if (temp == -999999.0){
					UNKNOWN();
				} else {
					MIB_RESPOND(true,LXS(temp));
				}
			}
		} else if isGroup("HDD") {
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(HddInfo::getDeviceCount()));
			} else if isSubGroup("TEMP") {
				getIndexOn(3);
				if (!idx){	UNKNOWN(); }
				int temp = HddInfo::getDeviceTemperature(idx-1);
				if (temp == 0){
					MIB_RESPOND(false,"Temperature information unavailable for device '"+HddInfo::getDeviceLabel(idx-1)+"'");
				} else if (temp == -999999){
					UNKNOWN();
				} else {
					MIB_RESPOND(true,LXS(temp));
				}
			}

		} else if isGroup("FORMAT") {
			size_t count = DataFormat::getKnownCount();
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(count));
			} else {
				getIndexOn(3);
				if (!idx){	UNKNOWN(); }
				DataFormat df = DataFormat::getFormatByNumber(idx);
				if (strEqual(df.getName(), "Unknown Data Format")){
					UNKNOWN();
				}
				if isSubGroup("NAME") {
					MIB_RESPOND(true,df.getName());
				} else if isSubGroup("PAYLOAD") {
					MIB_RESPOND(true,LXS(df.getFrameSize()));
				} else if isSubGroup("RATE") {
					MIB_RESPOND(true,LXS(df.getDataRate()));
				}
			}
		} else if isGroup("BUFFER") {
			if isSubGroup("RESTRICT") {
				MIB_RESPOND(false,"<MIB-ENTRY DEPRECATED>");
			} else {
				MIB_RESPOND(false,"<MIB-ENTRY DEPRECATED>");
			}
		} else if isGroup("LOG") {
			int count = Log::logCount();
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(count));
			} else if isSubGroup("ENTRY") {
				getSignedIndexOn(3);
				if (!sidx) {
					UNKNOWN();
				}
				string ll = (sidx > 0) ? Log::logEntry(sidx-1) : Log::logEntry(sidx);
				if (ll.empty()){
					UNKNOWN();
				}else {
					MIB_RESPOND(true,ll);
				}
			}
		} else if isGroup("DRSU") {
			size_t int_count = Storage::getDeviceCount(ST_INTERNAL);
			if isSubGroup("COUNT") {
				MIB_RESPOND(true,LXS(int_count));
			} else if isSubGroup("SELECTED") {
				string as = CONF_GET(ArraySelect);
				Storage* sto;
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_INTERNAL, as, accept, comment), NULL);
				if (sto==NULL || !accept){
					MIB_RESPOND(false, comment);
				} else {
					MIB_RESPOND(true,LXS(sto->getId()+1));
				}
			} else if isSubGroup("BARCODE") {
				string as = CONF_GET(ArraySelect);
				Storage* sto;
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_INTERNAL, as, accept, comment), NULL);
				if (sto==NULL || !accept){
					MIB_RESPOND(false, comment);
				} else {
					MIB_RESPOND(true,sto->getVolumeName());
				}
			} else if isSubGroup("INFO") {
				getIndexOn(3);
				if ((idx<1) || (idx>int_count)){
					UNKNOWN();
				}
				Storage* sto;
				SYSTEM_SAFE2(sto, getAlternateStorage(ST_INTERNAL, LXS(idx), accept, comment), NULL);
				if (sto==NULL || !accept){
					MIB_RESPOND(false, comment);
				} else {
					char buf[8192];
					string partition = sto->getPartition();
					size_t sz        = sto->getSize();
					size_t id        = (size_t) sto->getId() + 1;
					snprintf(buf,8192,"DRSU%.2lu %-64.64s %.16lu", id, partition.c_str(), sz);
					MIB_RESPOND(true,string(buf));
				}

			}
		} else if isGroup("TT-LAG") {
			Receiver* rx;
			SYSTEM_SAFE2(rx, getReceiver(accept, comment), NULL);
			if (rx==NULL || !accept){
				MIB_RESPOND(false, comment);
			}
			if isSubGroup("INITIAL") {
				MIB_RESPOND(true,LXS(rx->getLag(true)));
			} else {
				MIB_RESPOND(true,LXS(rx->getLag(false)));
			}
		}
		int i=0;
		foreach(string s, sl){
			LOGC(L_DEBUG, "Match "+LXS(i++) + ": '"+s+"'",ACTOR_WARNING_COLORS);
		}
	}
	UNKNOWN();

	accept=false; comment = "Unhandled MIB entry: '"+data+"'"; return;

}
