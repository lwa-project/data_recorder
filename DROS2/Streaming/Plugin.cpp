// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#include "Plugin.h"



Plugin::Plugin(const string& _name, TicketBuffer* _source, const TB_Geometry& _outputBufferGeometry):
	TicketBuffer("Plugin:"+_name+".buffer"),
	QueuedSubscriber("Plugin:"+_name+".subscriber"),
	ThreadPair("Plugin:"+_name, PG_COMPUTE, 0),
	source(_source),
	outputBufferGeometry(_outputBufferGeometry),
	bytesReceived(0),
	bytesSent(0)
	{
	in.t  = NULL;  in.next=0;  in.done=0;
	out.t = NULL; out.next=0; out.done=0;
	if (!source)
		LOGC(L_INFO, "["+GenericThread::getName()+"] Source is a NULL pointer", FATAL2_COLORS);


}

//
Plugin::~Plugin(){
}

void Plugin::run_master(){
	while (!isInterrupted()){
		if (getNextIn(outputBufferGeometry.framesize)){
			doneIn(true);
		}
	}
}
void Plugin::run_slave(){
}

void Plugin::start(){
	if (!source){
		LOGC(L_FATAL, "Program Error: can't start plugin with null source pointer", ACTOR_ERROR_COLORS);
		return;
	}

	LOGC(L_INFO, "["+ThreadPair::getName()+"] Start()", ACTOR_WARNING_COLORS);
	// set up our output buffer
	TicketBuffer::reset(outputBufferGeometry);
	// connect to input source
	source->subscribe(this);
	// start the threads
	ThreadPair::start();
}

void Plugin::stop(){
	// join the threads
	ThreadPair::stop();

	// if we had an input ticket, now's the time to release it.
	if (in.t != NULL){
		in.t->put();
		in.t = NULL;
	}

	LOGC(L_INFO, "["+ThreadPair::getName()+"] Unsubscribe from source", ACTOR_WARNING_COLORS);
	// disconnect input source
	source->unsubscribe(this);

	LOGC(L_INFO, "["+ThreadPair::getName()+"] Announce disconnect", ACTOR_WARNING_COLORS);
	TicketBuffer::notifyAllSubscribersDisconnect();
	LOGC(L_INFO, "["+ThreadPair::getName()+"] Wait subscribers disconnect", ACTOR_WARNING_COLORS);

	// wait for subscribers to disconnect
	while(TicketBuffer::haveSubscribers()){
		// do nothing
	}
	LOGC(L_INFO, "["+ThreadPair::getName()+"] All subscribers disconnected", ACTOR_WARNING_COLORS);

	// if we had an output ticket, now's the time to release it.
	if (out.t != NULL){
		out.t->returnEmpty();
		out.t = NULL;
	}

	// free the buffer
	TicketBuffer::uninit();
	LOGC(L_INFO, "["+ThreadPair::getName()+"] Finish Run()", ACTOR_WARNING_COLORS);


}



void* Plugin::getNextIn(size_t size){
	if (!in.t){
		bool done=false;
		while (!done){
			in.t = QueuedSubscriber::getNext();
			if (!in.t){
				return NULL;
			}
			if (in.t->cnt_used == 0){
				in.t->put();
				continue;
			}
			if (in.t->fsize != size){
				in.t->put();
				continue;
			}
			in.next=0;
			in.done=0;
			done=true;
		}
	}
	if (!in.t){
		return NULL;
	}
	if (in.next == in.t->cnt_used){
		return NULL;
	}
	bytesReceived += in.t->fsize;
	return in.t->iovs[in.next++].iov_base;
}

void Plugin::doneIn(bool release){
	if (!in.t || (in.done == in.t->cnt_used) || (in.done >= in.next)){
		LOGC(L_FATAL, "Program Error: called done in on Plugin w/ no ticket, or unmatched get/put", ACTOR_ERROR_COLORS);
	} else {
		in.done++;
		if ((in.done == in.t->cnt_used) || (release && (in.done==in.next))){
			in.t->put();
			in.t=NULL;
		}
	}
}

void* Plugin::getNextOut(size_t size){
	if (!out.t){
		bool done=false;
		while (!done){
			out.t = TicketBuffer::nextFreeTicket();
			if (!out.t){
				return NULL;
			}
			if (out.t->cnt_alloc == 0){
				out.t->returnEmpty();
				continue;
			}
			if (out.t->fsize != size){
				out.t->returnEmpty();
				continue;
			}
			initializeDownstreamTicket(out.t);
			out.next=0;
			out.done=0;
			done=true;
		}
	}
	if (!out.t){
		return NULL;
	}
	if (out.next == out.t->cnt_alloc){
		return NULL;
	}
	return out.t->iovs[out.next++].iov_base;
}

void Plugin::doneOut(bool release){
	if (!out.t || (out.done == out.t->cnt_alloc) || (out.done > out.next)){
		LOGC(L_FATAL, "Program Error: called done out on Plugin w/ no ticket, or unmatched get/put", ACTOR_ERROR_COLORS);
	} else {
		bytesSent += out.t->fsize;
		out.done++;
		if ((out.done == out.t->cnt_alloc) || (release && (out.done == out.next))){
			out.t->notifyFill(out.done);
			out.t=NULL;
		}
	}
}




void Plugin::initializeDownstreamTicket(TicketBuffer::Ticket*& _t){
	for (size_t i=0; i<_t->cnt_alloc; i++){
		_t->mhdrs[i].msg_len           = 0;
		_t->mhdrs[i].msg_hdr.msg_flags = 0;
	}
	_t->cnt_used = 0;
	(*_t->valid) = true;
}
size_t Plugin::getReceiveRate(){
	static bool initialized=false;
	static TimeStamp last(0,0);
	if (!initialized){
		last = Time::now();
		initialized = true;
	}
	TimeStamp present = Time::now();
	millisecond_delta elapsed = Time::getTimeStampDelta_ms(last,present);
	if (!elapsed) elapsed=1;

	size_t temp = bytesReceived * 1000ll / elapsed;
	bytesReceived = 0;
	last=present;
	return temp;
}
size_t Plugin::getSendRate(){
	static bool initialized=false;
	static TimeStamp last(0,0);
	if (!initialized){
		last = Time::now();
		initialized = true;
	}
	TimeStamp present = Time::now();
	millisecond_delta elapsed = Time::getTimeStampDelta_ms(last,present);
	if (!elapsed) elapsed=1;

	size_t temp = bytesSent * 1000ll / elapsed;
	bytesSent = 0;
	last=present;
	return temp;
}


