// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#ifndef BASERECORDER_H_
#define BASERECORDER_H_

#include "../Threading/GenericThread.h"
#include "../System/File.h"
#include "TicketBuffer.h"
#include "QueuedSubscriber.h"



enum FileEvent     {FE_INIT, FE_CONNECT, FE_DISCONNECT, FE_START, FE_STOP, FE_LIMIT, FE_ERROR, FE_DONE, FE_FILE_CHANGED};
class BaseRecorder: public GenericThread, public QueuedSubscriber {
public:

	class FileCallbackHandler{
	public:
		virtual void handleEvent(BaseRecorder* r, FileEvent e, File* f){return;}
	};

	BaseRecorder(FileCallbackHandler* _cb, bool doSidCheck):
		GenericThread("BaseRecorder", PG_IO, 1),
		QueuedSubscriber("BaseRecorder"),
		buf(NULL),
		outfile(NULL),
		bytesWrittenThisFile(0),
		bytesWrittenThisSession(0),
		size_limit(0),
		recording(false),
		cb(_cb),
		_error(false),
		doSidCheck(doSidCheck)
	{
	}

	virtual ~BaseRecorder(){

	}

	virtual void setOutputFile(File* _outfile=NULL, size_t _size_limit=0){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (outfile){
			LOGC(L_INFO, "[Recorder] Stopped using output file: '"+outfile->getFullPath()+"'", ACTOR_COLORS);
		}
		if(_outfile){
			LOGC(L_INFO, "[Recorder] Started using output file: '"+_outfile->getFullPath()+"'", ACTOR_COLORS);
		}
		if(_size_limit){
			LOGC(L_INFO, "[Recorder] Set size limit to "+LXS(_size_limit)+" bytes", ACTOR_COLORS);
		}
		outfile    = _outfile;
		size_limit = _size_limit;
		onFileEvent(FE_FILE_CHANGED);
	}

	virtual void startRecording(){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (!buf){
			LOGC(L_ERROR, "Tried to start the recorder, but was not connected.", ACTOR_ERROR_COLORS);
			onFileEvent(FE_ERROR);
			return;
		}else{
			recording=true;
			onFileEvent(FE_START);

		}
	}

	virtual void stopRecording(){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (!buf){
			LOGC(L_ERROR, "Tried to stop the recorder, but was not connected.", ACTOR_ERROR_COLORS);
			onFileEvent(FE_ERROR);
			return;
		}else{
			if (!buf){
				LOGC(L_ERROR, "Tried to stop the recorder, but was not recording.", ACTOR_ERROR_COLORS);
				onFileEvent(FE_ERROR);
				return;
			}else{
				recording=false;
				onFileEvent(FE_STOP);
			}
		}
	}

	virtual void connect(TicketBuffer* buf){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (this->buf){
			LOGC(L_ERROR, "Tried to connect the recorder, but was already connected.", ACTOR_ERROR_COLORS);
			onFileEvent(FE_ERROR);
			return;
		}else{
			if (!buf){
				LOGC(L_ERROR, "Tried to connect the recorder with null pointer.", ACTOR_ERROR_COLORS);
				onFileEvent(FE_ERROR);
				return;
			} else {
				this->buf = buf;
				buf->subscribe(this);
				onFileEvent(FE_CONNECT);
			}
		}
	}

	virtual void disconnect(){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (!buf){
			LOGC(L_ERROR, "Tried to disconnect the recorder, but was not connected.", ACTOR_ERROR_COLORS);
			onFileEvent(FE_ERROR);
			return;
		}else{
			if (recording){
				LOGC(L_ERROR, "Tried to disconnect the recorder while recording.", ACTOR_ERROR_COLORS);
				onFileEvent(FE_ERROR);
				return;
			} else{
				buf->unsubscribe(this);
				this->buf = NULL;
				onFileEvent(FE_DISCONNECT);
			}
		}
	}
	void __doSidCheck(TicketBuffer::Ticket*t){
		static size_t last_sid = (size_t) -1ll;
		size_t cnt = t->cnt_used;
		for (size_t i=0; i<cnt; i++){
			size_t* sid=NULL;
			switch(t->fsize){
			case DRX_FRAME_SIZE:
				sid = (size_t*)(&((DrxFrame*)t->iovs[i].iov_base)->samples[0]);
				break;
			case TBN_FRAME_SIZE:
				sid = (size_t*)(&((TbnFrame*)t->iovs[i].iov_base)->samples[0]);
				break;
			case TBW_FRAME_SIZE:
				sid = (size_t*)(&((TbwFrame*)t->iovs[i].iov_base)->samples_4bit[0]);
				break;
			default:
				sid=NULL;
				break;
			}
			if (sid){
				size_t _sid = *sid;
				if (_sid != (last_sid+1)){
					string delta;
					if (_sid < last_sid){
						delta="-"+LXS(last_sid-_sid);
					} else {
						delta=LXS(_sid-last_sid);
					}
					LOGC(L_ERROR, "SID GAP: " + LXS(_sid) + " when expecting " + LXS(last_sid+1)+ " (gap of size "+delta+")" , ACTOR_ERROR_COLORS);
				}
				last_sid = _sid;
			}
		}
	}

	void writeTicket(TicketBuffer::Ticket*t){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		struct iovec  io;
		struct iovec* iovPtr = NULL;
		size_t        iovcnt = 0;
		size_t        bytesToWrite = 0;
		size_t        bytesWrittenThisTicket = 0;
		size_t        bytesWrittenThisAttempt = 0;
		int*          fd = NULL;
		bool          done=false;
		size_t        retry_count = 10;
		if (!t){
			LOGC(L_ERROR, "Tried to write ticket but ticket was null pointer.", ACTOR_ERROR_COLORS);
			onFileEvent(FE_ERROR);
			return;
		}
		if (!outfile){
			LOGC(L_ERROR, "Tried to write ticket but file was null pointer.", ACTOR_ERROR_COLORS);
			goto error;
		}
		if (!outfile->isOpen()){
			LOGC(L_ERROR, "Tried to write ticket but file was not open.", ACTOR_ERROR_COLORS);
			goto error;
		}
		fd = (int*)outfile->getDescriptor();
		if (!fd){
			LOGC(L_ERROR, "Tried to write ticket but file descriptor pointer was null.", ACTOR_ERROR_COLORS);
			goto error;
		}
		if ((*fd) <0){
			LOGC(L_ERROR, "Tried to write ticket but file descriptor was bad.", ACTOR_ERROR_COLORS);
			goto error;
		}
		if (t->isContinuous()){
			bytesToWrite = t->cnt_used * t->fsize;
			io.iov_base  = t->iovs[0].iov_base;
			io.iov_len   = bytesToWrite;
			iovPtr       = &io;
			iovcnt       = 1;

		} else {
			bytesToWrite =0;
			iovPtr = t->iovs;
			iovcnt = t->cnt_used;
			for (size_t i =0; i<iovcnt; i++ ){
				bytesToWrite += iovPtr[i].iov_len;
			}
		}
		while (! done && retry_count){
			int result=writev((*fd),iovPtr,iovcnt);
			switch(result){
			case 0:
				retry_count--; continue;
			case -1:
				switch (errno){
				case EINTR: // fall through
				case EAGAIN:
				case 512:    // 512 is a special case of kernel leaking a restartable interrupted errno into user space
					retry_count--;
					continue;
					break;
				default:
					LOGC(L_ERROR, "IO error writing to file: '"+string(strerror(errno))+"'", ACTOR_ERROR_COLORS);
					done=true;
					goto error;
					break;
				};
				break;
			default:

				bytesWrittenThisAttempt = (size_t) result;
				bytesWrittenThisTicket += bytesWrittenThisAttempt;
				if (bytesWrittenThisAttempt != bytesToWrite){
					if (t->isContinuous()){
						bytesToWrite -= bytesWrittenThisAttempt;
						io.iov_base   = (void*)(&(((char*)io.iov_base)[bytesWrittenThisAttempt]));
						retry_count--;
						continue;
					} else {
						LOGC(L_ERROR, "Partial completeion writing to file from discontiguous buffer", ACTOR_ERROR_COLORS);
						done=true;
						goto error;
					}
				} else {
					done=true;
				}
				break;
			}
		}
		if (done){
			cout << "----------------------------------------------------------------- " << Storage::humanReadable(bytesWrittenThisTicket)<<" of "<< Storage::humanReadable(bytesToWrite) << " in " <<LXS(t->cnt_used)<<" IOVs" << endl;
			bytesWrittenThisSession += bytesWrittenThisTicket;
			bytesWrittenThisFile    += bytesWrittenThisTicket;
			if ((size_limit) && (bytesWrittenThisFile >= size_limit)){
				LOGC(L_ERROR, "[BaseRecorder]: File size limit reached: " + LXS(bytesWrittenThisFile) + " >= " + LXS(size_limit) , ACTOR_ERROR_COLORS);
				recording = false;
				onFileEvent(FE_LIMIT);
			}

		} else {
			LOGC(L_ERROR, "[BaseRecorder]: Too many retries", ACTOR_ERROR_COLORS);
		}
		// completed writing the expected way, release the ticket and continue
		t->put();

		return;

		error:
			LOGC(L_ERROR, "[BaseRecorder]: unknown error.", ACTOR_ERROR_COLORS);
			t->put();
			onFileEvent(FE_ERROR);
			return;
	}


	virtual void doAbort(){
		onReset();
		GenericThread::doAbort();
	}

	virtual void onReset(){
		LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		QueuedSubscriber::onReset();
		{
			SERIALIZE_ACCESS();
			// any add'l reset actions here
		}
	}

	virtual void run(){
		LOGC(L_INFO, "[BaseRecorder] : Start", ACTOR_COLORS);
		onFileEvent(FE_INIT);
		while (!isInterrupted()){
			SERIALIZE_ACCESS();
			TicketBuffer::Ticket*t = getNext();
			if (t==NULL){
				RELEASE_ACCESS_LOCK();
				yield();
			} else {
				if (!recording){
					t->put();
					continue;
				}else {
					if (doSidCheck){
						__doSidCheck(t);
					}
					// write ticket content to file
					writeTicket(t);
				}
			}
		}
		onFileEvent(FE_DONE);
		LOGC(L_INFO, "[BaseRecorder] : Stop", ACTOR_COLORS);
	}

	void onFileEvent(FileEvent e){
		//LOGC(L_INFO, "[BaseRecorder] : Event : " + eventString(e), ACTOR_ERROR_COLORS);
		if (e == FE_ERROR){
			_error=true;
		}
		cb->handleEvent(this, e, outfile);
	}

	size_t getBytesWrittenSinceConnected()const {
		return bytesWrittenThisSession;
	};

	size_t getBytesWrittenSinceFileChange()const {
		return bytesWrittenThisFile;
	};
/*
	void resetFileSize(){
		LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		SERIALIZE_ACCESS();
		if (outfile && outfile->isOpen()){
			volatile int* fd = outfile->getDescriptor();
			if (fd && (*fd!= -1)){
				lseek(*fd, 0, SEEK_SET);
				bytesWrittenThisSession=0;
			}
		}
	}
	*/
	virtual bool wasError(){
		return _error;
	}
	string eventString(FileEvent e){
		switch(e){
		case FE_INIT:         return "Initialized " + Time::humanReadable(Time::now());
		case FE_CONNECT:      return "Connected " + Time::humanReadable(Time::now());
		case FE_DISCONNECT:   return "Disconnected " + Time::humanReadable(Time::now());
		case FE_START:        return "Recording Started " + Time::humanReadable(Time::now());
		case FE_STOP:         return "Recording Stopped " + Time::humanReadable(Time::now());
		case FE_LIMIT:        return "Filesize limit reached " + Time::humanReadable(Time::now());
		case FE_ERROR:        return "error condition " + Time::humanReadable(Time::now());
		case FE_DONE:         return "done" + Time::humanReadable(Time::now());
		case FE_FILE_CHANGED: return "File changed " + Time::humanReadable(Time::now());
		}
		return "Unknown event type";
	}

private:
	BaseRecorder():QueuedSubscriber("BaseRecorder"){}
	DECLARE_ACCESS_MUTEX();
	TicketBuffer*          buf;
	File*                  outfile;
	volatile size_t        bytesWrittenThisFile;
	volatile size_t        bytesWrittenThisSession;
	volatile size_t        size_limit;
	volatile bool          recording;
	FileCallbackHandler*   cb;
	bool                   _error;
	bool                   doSidCheck;

};

#endif /* BASERECORDER_H_ */


