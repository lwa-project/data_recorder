// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef FILEWRITER_H_
#define FILEWRITER_H_

#include "../System/File.h"

#include "SubscriberThread.h"

enum FileWriterState {FWS_INVALID, FWS_INITIALIZED, FWS_CONNECTED, FWS_RECORDING, FWS_DISCONNECTED, FWS_UNINIT, FWS_DONE};
class FileWriter: public SubscriberThread {
public:
	class EventListener{
	public:
		virtual void onFWThreadStart(FileWriter*who){}
		virtual void onFWRecordStart(FileWriter*who){}
		virtual void onFWError(FileWriter*who){}
		virtual void onFWRecordStop(FileWriter*who){}
		virtual void onFWThreadStop(FileWriter*who){}
	};

	FileWriter(
			EventListener* _owner,
			TicketBuffer* _buf,
			File* _file,
			TimeSlot _ts=Time::always,
			size_t _size_limit=0,
			bool _doSidCheck=false
	):
	SubscriberThread("FileWriter:" + ( (_file != NULL) ? _file->getFullPath() : "<Invaild File Object>" ),_buf),
	owner(_owner),
	file(_file),
	bytesWrittenThisFile(0),
	ts(_ts),
	size_limit(_size_limit),
	size_limit_reached(false),
	time_limit_reached(false),
	manually_stopped(false),
	error_occurred(false),
	notified_started(false),
	doSidCheck(_doSidCheck),
	state(FWS_INVALID){

	}
	virtual ~FileWriter(){

	}

	// External interface
	void stopRecording(){
		manually_stopped = true;
	}

	FileWriterState getState()      const {return state;}
	size_t getBytesWritten()        const {return bytesWrittenThisFile;}
	size_t hasErrorOccurred()       const {return error_occurred;}
	size_t hasReachedTimeLimit()    const {return time_limit_reached;}
	size_t hasReachedSizeLimit()    const {return size_limit_reached;}
	size_t hasBeenManuallyStopped() const {return manually_stopped;}

	// Queued Subscriber interaction
	virtual bool onInit(){
		state = FWS_INITIALIZED;
		if (owner!=NULL) owner->onFWThreadStart(this);
		return ((file != NULL) && (file->isOpen()));
	}

	virtual bool onConnected(){
		// do nothing
		state = FWS_CONNECTED;
		return true;
	}

	virtual bool onReceiveLoopStart(const size_t& size, const size_t& framesize, const size_t& framesPerTicket){
		state = FWS_RECORDING;
		// do nothing (generic writer doesn't care about geometry
		return canContinue();
	}

	virtual bool onTicketReceived(TicketBuffer::Ticket* t){
		if (!canContinue()){
			t->put();
		}
		if (doSidCheck) __doSidCheck(t);
		switch (Time::compare(ts,Time::now())){
		case -1:
			// not started
			break;
		case 0:
			if (!notified_started){
				notified_started=true;
				if (owner!=NULL) owner->onFWRecordStart(this);
			}
			// goldilocks
			writeTicket(t);
			if ((size_limit) && (bytesWrittenThisFile >= size_limit)){
				LOGC(L_INFO, "[FileWriter]: File size limit reached: " + LXS(bytesWrittenThisFile) + " >= " + LXS(size_limit) , ACTOR_ERROR_COLORS);
				size_limit_reached=true;
			}
			break;
		case 1:
			// too late
			time_limit_reached=true;
			break;
		default:
			LOGC(L_ERROR, "[FileWriter]: Reached unreachable code: " + string(__FILE__) + string (__FUNCTION__) , ACTOR_ERROR_COLORS);
			error_occurred=true;
			break;
		}
		t->put();
		return canContinue();
	}

	virtual bool onTicketBufferEmpty(){
		int tsr = Time::compare(ts,Time::now());
		if (tsr==0){
			if (!notified_started){
				notified_started=true;
				if (owner!=NULL) owner->onFWRecordStart(this);
			}
		} else if(tsr == 1){
			LOGC(L_INFO, "[FileWriter]: File time limit reached", ACTOR_COLORS);
			time_limit_reached=true;
		}
		return canContinue();
	}

	virtual void onDisonnected(){
		// do nothing
		state = FWS_DISCONNECTED;
	}
	virtual void onUninit(){
		file->close();
		if ( !size_limit_reached && !time_limit_reached ){
			file->setAttribute("opComplete","NO ");
			if (manually_stopped){
				file->setAttribute("opCompleteReason","manually aborted");
			} else if (error_occurred){
				file->setAttribute("opCompleteReason","I/O error occurred");
			} else {
				file->setAttribute("opCompleteReason","thread interrupted by non-standard means (probably INI/SHT/EXT command)");
			}
		} else {
			file->setAttribute("opComplete","YES");
			if (size_limit_reached){
				file->setAttribute("opCompleteReason","Operation file size limit reached");
			} else if (time_limit_reached){
				file->setAttribute("opCompleteReason","Operation time limit reached");
			}
		}
		state = FWS_UNINIT;
	}
	virtual void onDone(){
		if (owner!=NULL) owner->onFWThreadStop(this);
		state = FWS_DONE;
	}

	virtual bool canContinue(){
		if (size_limit_reached || time_limit_reached || manually_stopped || error_occurred){
			if (owner!=NULL){
				if (error_occurred){
					 owner->onFWError(this);
				}
				owner->onFWRecordStop(this);
			}
			return false;
		} else {
			return true;
		}
	}

private:
	EventListener* owner;
	File*         file;
	size_t        bytesWrittenThisFile;
	TimeSlot      ts;
	size_t        size_limit;
	volatile bool size_limit_reached;
	volatile bool time_limit_reached;
	volatile bool manually_stopped;
	volatile bool error_occurred;
	bool          notified_started;
	bool          doSidCheck;
	volatile FileWriterState state;

	// THE MEAT
	void writeTicket(TicketBuffer::Ticket*t){
		//LOGC(L_INFO, string(__FILE__) +":"+string(__FUNCTION__)+"()" , ACTOR_ERROR_COLORS);
		struct iovec  io;
		struct iovec* iovPtr = NULL;
		size_t        iovcnt = 0;
		size_t        bytesToWrite = 0;
		size_t        bytesWrittenThisTicket = 0;
		size_t        bytesWrittenThisAttempt = 0;
		int*          fd = NULL;
		bool          done=false;
		size_t        retry_count = 10;
		if (!file->isOpen()){
			LOGC(L_ERROR, "Tried to write ticket but file was not open.", ACTOR_ERROR_COLORS);
			error_occurred = true;
			return;
		}
		fd = (int*)file->getDescriptor();
		if (!fd){
			LOGC(L_ERROR, "Tried to write ticket but file descriptor pointer was null.", ACTOR_ERROR_COLORS);
			error_occurred = true;
			return;
		}
		if ((*fd) <0){
			LOGC(L_ERROR, "Tried to write ticket but file descriptor was bad.", ACTOR_ERROR_COLORS);
			error_occurred = true;
			return;
		}
		if (t->isContinuous()){
			bytesToWrite = t->cnt_used * t->fsize;
			io.iov_base  = t->iovs[0].iov_base;
			io.iov_len   = bytesToWrite;
			iovPtr       = &io;
			iovcnt       = 1;
		} else {
			bytesToWrite =0;
			iovPtr = t->iovs;
			iovcnt = t->cnt_used;
			for (size_t i =0; i<iovcnt; i++ ){
				bytesToWrite += iovPtr[i].iov_len;
			}
		}
		while (! done && retry_count){
			int result=writev((*fd),iovPtr,iovcnt);
			switch(result){
			case 0:
				retry_count--; continue;
			case -1:
				switch (errno){
				case EINTR: // fall through
				case EAGAIN:
				case 512:    // 512 is a special case of kernel leaking a restartable interrupted errno into user space
					retry_count--;
					continue;
					break;
				default:
					LOGC(L_ERROR, "IO error writing to file: '"+string(strerror(errno))+"'", ACTOR_ERROR_COLORS);
					error_occurred = true;
					return;
				};
				break;
			default:
				bytesWrittenThisAttempt = (size_t) result;
				bytesWrittenThisTicket += bytesWrittenThisAttempt;
				if (bytesWrittenThisAttempt != bytesToWrite){
					if (t->isContinuous()){
						bytesToWrite -= bytesWrittenThisAttempt;
						io.iov_base   = (void*)(&(((char*)io.iov_base)[bytesWrittenThisAttempt]));
						retry_count--;
						continue;
					} else {
						LOGC(L_WARNING, "Partial completeion writing to file from discontiguous buffer", ACTOR_WARNING_COLORS);
						return;
					}
				} else {
					done=true;
				}
				break;
			}
		}
		bytesWrittenThisFile    += bytesWrittenThisTicket;
		if (done){/*
			cout << "\t\t----------* "
					<< Storage::humanReadable(bytesWrittenThisTicket)
					<< " of "
					<< Storage::humanReadable(bytesToWrite)
					<< " in "
					<< LXS(t->cnt_used)
					<< " IOVs" << endl;*/
		} else {
			LOGC(L_ERROR, "[FileWriter]: Too many retries", ACTOR_ERROR_COLORS);
		}
		// completed writing the expected way
		return;
	}
	void __doSidCheck(TicketBuffer::Ticket*t){
			static size_t last_sid = (size_t) -1ll;
			size_t cnt = t->cnt_used;
			for (size_t i=0; i<cnt; i++){
				size_t* sid=NULL;
				switch(t->fsize){
				case DRX_FRAME_SIZE:
					sid = (size_t*)(&((DrxFrame*)t->iovs[i].iov_base)->samples[0]);
					break;
				case TBN_FRAME_SIZE:
					sid = (size_t*)(&((TbnFrame*)t->iovs[i].iov_base)->samples[0]);
					break;
				case TBW_FRAME_SIZE:
					sid = (size_t*)(&((TbwFrame*)t->iovs[i].iov_base)->samples_4bit[0]);
					break;
				default:
					sid=NULL;
					break;
				}
				if (sid){
					size_t _sid = *sid;
					if (_sid != (last_sid+1)){
						string delta;
						if (_sid < last_sid){
							delta="-"+LXS(last_sid-_sid);
						} else {
							delta=LXS(_sid-last_sid);
						}
						LOGC(L_ERROR, "SID GAP: " + LXS(_sid) + " when expecting " + LXS(last_sid+1)+ " (gap of size "+delta+")" , ACTOR_ERROR_COLORS);
					}
					last_sid = _sid;
				}
			}
		}

};

#endif /* FILEWRITER_H_ */
