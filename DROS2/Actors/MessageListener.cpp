// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "MessageListener.h"
#include "../Common/CommonICD.h"
#include "../Common/Actors.h"

MessageListener::MessageListener(unsigned short port, size_t waitTime):
	GenericThread("MessageListener", PG_IDLE),
	port(port),
	sd(-1),
	waitTime(waitTime)
	{
}

void MessageListener::start(){
	struct sockaddr_in  local_adr;
	sd  					    = -1;
	local_adr.sin_family 		= AF_INET;
	local_adr.sin_port			= htons(port);
	local_adr.sin_addr.s_addr 	= INADDR_ANY;
	memset(local_adr.sin_zero, '\0', sizeof local_adr.sin_zero);
	// create the socket
	sd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sd < 0)	{
		LOG(L_ERROR, "[MessageListener] : socket() error");
		return;
	}
	// bind the socket to localhost::port specified above
	int result = ::bind(sd, (struct sockaddr *) &local_adr,	(socklen_t)sizeof(struct sockaddr));
	if (result != 0) {
		close(sd);
		LOG(L_ERROR, "[MessageListener] : bind() error");
		return;
	}
	LOGC(L_INFO, "[MessageListener] : Messaging socket opened on port" + LXS(port), OBJECT_COLORS);
	GenericThread::start();
}
void MessageListener::run(){
	char                     msgbuf[MESSAGE_MAX_SIZE + 1];
	struct sockaddr_storage  remote_adr;
	socklen_t        	     remote_adr_size = sizeof(struct sockaddr_storage);
	PackedMessage*           pm              = (PackedMessage*) msgbuf;
	WaitQueue<Message> *     wq              = NULL;

	bzero((void*)&remote_adr, sizeof(struct sockaddr));

	LOGC(L_INFO, "[MessageListener] Waiting for message queue to open.",ACTOR_COLORS);
	while((wq==NULL) && (! this->isInterrupted())){
		wq=WaitQueueManager::getInstance()->getByName<Message>("MessageProcessor");
	}

	LOGC(L_INFO, "[MessageListener] Running.",ACTOR_COLORS);
	struct timeval to;
	fd_set readfds;

	while ((wq!=NULL) && (sd!=-1) && !isInterrupted()){
		FD_ZERO(&readfds);
		FD_SET(sd,&readfds);
		to.tv_sec = 1;
		to.tv_usec=(waitTime * 1000ll);
		int res = select(sd+1,&readfds,NULL,NULL,&to);
		if (res == 0){
			// do nothing
		} else if (res == -1){
			if (errno != EINTR) LOGC(L_ERROR, string("[MessageListener]: select(): '") + strerror(errno) + string("'."), ACTOR_ERROR_COLORS);
		} else {


			// read message from socket
			res = ::recvfrom(sd,(void*)msgbuf,MESSAGE_MAX_SIZE,MSG_WAITALL,(sockaddr*) &remote_adr, &remote_adr_size);
			if (!res) continue;
			if (res<0){
				LOGC(L_ERROR, string("[MessageListener] : Can't receive: ''") + strerror(errno), MESSAGING_ERROR_COLORS);
				continue;
			}
			if (! CommonICD::_validate(pm,(size_t) res)){
				LOGC(L_ERROR, string("[MessageListener] : Received invalid message @ CommonICD::_validate()"), MESSAGING_ERROR_COLORS);
				continue;
			}

			// extract message fields
			string dest     = CommonICD::_destination(pm);
			size_t ref      = CommonICD::_reference(pm);
			size_t mpm      = CommonICD::_mpm(pm);
			size_t mjd      = CommonICD::_mjd(pm);
			size_t datalen  = CommonICD::_datalength(pm);
			string type     = CommonICD::_type(pm);
			string sender   = CommonICD::_sender(pm);
			string data     = CommonICD::_data(pm);

			// check that the message was intended for us
			if (dest.compare(CONF_GET(MyReferenceDesignator)) && dest.compare("ALL")){
				LOGC(L_WARNING, string("[MessageListener] : Received message for another subsystem: '"+dest+"'"), MESSAGING_COLORS);
				continue;
			}

			// extract IP info
			IpSpec sourceIpSpec(remote_adr);
			IpSpec destIpSpec(CONF_GET(MessageOutPort), sourceIpSpec.getIp());

			// sanity check
			bool consistent =  ((datalen + MESSAGE_MIN_SIZE) == (size_t) res);

			if (!consistent){
				LOGC(L_ERROR, string("[MessageListener] : Received message with inconsistent length"), MESSAGING_ERROR_COLORS);
				ResponseSender::respond(
						Message(sourceIpSpec, destIpSpec, dest, sender, type, ref, mjd, mpm, "", StringStringMap()),
						false, "Bad Message Length"
				);
				continue;
			}

			// extract metatags and strip them from the data
			StringStringMap meta = Utility::extractMeta(data);

			// look for message redirection in the message metadata
			if (meta.count("RESPOND")){
				string responseIp = meta["RESPOND"];
				IpSpec redirect(responseIp);
				LOGC(L_WARNING, string("[MessageListener] Redirection ==> ") + responseIp, SECURITY_COLORS);
				if (redirect.isIp() && redirect.hasIp() && redirect.hasPort()){
					destIpSpec = redirect;
				} else {
					LOGC(L_WARNING, string("[MessageListener] Bad or Incomplete Redirection... Using default"), SECURITY_COLORS);
				}
			}

			// ok, so here we have a valid, consistent, metadata-stripped message and respondto-updated set of strings.
			// build the message and queue it, it's in the message processor's hands now
			MessageProcessor::process(Message(sourceIpSpec, destIpSpec, dest, sender, type, ref, mjd, mpm, data, meta));
		}
		wq=WaitQueueManager::getInstance()->getByName<Message>("MessageProcessor");
	}
	LOGC(L_INFO, "[MessageListener] Stopped.",ACTOR_COLORS);

}


void MessageListener::stop(){
	close(sd);
	GenericThread::stop();
}
MessageListener::~MessageListener(){

}


