// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef COPYOPERATION_H_
#define COPYOPERATION_H_

#include "ThreadOperation.h"

#define TRANSFER_SIZE 4194304lu

class CopyOperation: public ThreadOperation {
public:
	CopyOperation(size_t reference,
			Storage* s1, Storage* s2,
			File* tagfile, File* extfile,
			const size_t offset, const size_t size,
			const string extdev):
		ThreadOperation("Copy",reference),
		s1(s1), s2(s2),
		tagfile(tagfile), extfile(extfile),
		size(size),
		extdev(extdev), curTagOffset(offset), written(0),
		_tagname("<unknown>"),
		_tagformat("<unknown>"),
		_extname("<unknown>"){
	}


	virtual void threadOpRun(){
		int         in_fd            = -1;
		int         out_fd           = -1;
		size_t      remaining        = 0;
		size_t      curTransferSize  = 0;
		int         res1             = 0;
		int         res2             = 0;
		size_t      bytes_read       = 0;
		size_t      bytes_written    = 0;
		TimeStamp   start            = __TimeStamp();
		TimeStamp   stop             = __TimeStamp();
		TimeStamp   delta            = __TimeStamp();
		millisecond elapsed          = 0;
		double      bw               = 0;
		char*       buf              = (char*) malloc(TRANSFER_SIZE);


		if (!buf){
			LOGC(L_ERROR, "[Copy] : Can't allocate transfer buffer.", OPERATION_ERROR_COLORS);
			goto cleanup;
		}
		bzero((void*)buf,TRANSFER_SIZE);
		if (!tagfile){
			LOGC(L_ERROR, "[Copy] : Missing input file.", OPERATION_ERROR_COLORS);
			goto cleanup;
		}
		_tagname   = tagfile->getName();
		_tagformat = tagfile->getAttribute("OpFormat");
		if (!tagfile->isOpen()){
			LOGC(L_ERROR, "[Copy] : Input file not open.", OPERATION_ERROR_COLORS);
			goto cleanup;
		}
		if (!extfile){
			LOGC(L_ERROR, "[Copy] : Missing output file.", OPERATION_ERROR_COLORS);
			goto cleanup;
		}
		if (!extfile->isOpen()){
			LOGC(L_ERROR, "[Copy] : Output file not open.", OPERATION_ERROR_COLORS);
			goto cleanup;
		}
		_extname = extfile->getName();


		in_fd  = *(tagfile->getDescriptor());
		out_fd = *(extfile->getDescriptor());
		start = Time::now();
		LOGC(L_INFO, "[Copy] : Starting copy " + Time::humanReadable(start), OPERATION_COLORS);


		while((!isInterrupted()) && (written<size)){
			remaining    = size-written;
			curTransferSize = min(remaining,TRANSFER_SIZE);
			if ((size_t) lseek(in_fd,curTagOffset,SEEK_SET)!=curTagOffset){
				LOGC(L_ERROR, "[Copy] : Can't seek input file.", OPERATION_ERROR_COLORS);
			}

			res1 = ::read(in_fd,buf,curTransferSize);
			switch(res1){
			case  0: continue;
			case -1:
				if (errno == EAGAIN) continue;
				LOGC(L_ERROR, "[Copy] : Can't read from input file: '"+string(strerror(errno))+"'", OPERATION_ERROR_COLORS);
				goto cleanup;
			default:
				bytes_read = (size_t) res1;
				if (!bytes_read) continue;
				break;
			}

			res2 = ::write(out_fd,buf,bytes_read);
			switch(res2){
			case  0: continue;
			case -1:
				if (errno == EAGAIN) continue;
				LOGC(L_ERROR, "[Copy] : Can't write to output file: '"+string(strerror(errno))+"'", OPERATION_ERROR_COLORS);
				goto cleanup;
			default:
				bytes_written = (size_t) res2;
				curTagOffset += bytes_written;
				written      += bytes_written;
				break;
			}
		}
		stop = Time::now();
		LOGC(L_INFO, "[Copy] : Finishing copy " + Time::humanReadable(stop), OPERATION_COLORS);

		delta =Time::getTimeStampDelta(start,stop);
		elapsed = delta.MPM + (delta.MJD * MILLIS_PER_DAY) + 1;
		bw = ((double)written * 1000lu) / ((double)elapsed);
		LOGC(L_INFO, "[Copy] : Copy volume:  " + Storage::humanReadable(written) , OPERATION_COLORS);
		LOGC(L_INFO, "[Copy] : Copy time:    " + LXS(elapsed) + " ms" , OPERATION_COLORS);
		LOGC(L_INFO, "[Copy] : Copy rate:    " + Storage::humanReadableBW(bw) , OPERATION_COLORS);
		LOGC(L_INFO, "[Copy] : Starting cleanup", OPERATION_COLORS);
		cleanup:
		if (buf) free(buf);
		if (tagfile && tagfile->isOpen()) tagfile->close();
		if (s1 && tagfile) s1->putFile(tagfile);
		if (extfile && extfile->isOpen()) extfile->close();
		if (s2 && extfile) s2->putFile(extfile);
		LOGC(L_INFO, "[Copy] : Cleanup complete. Operation finished.", OPERATION_COLORS);
	}

	virtual bool threadOpCancel(bool started){
		doAbort();
		return true;
	}

	virtual string getOpTag()const{       return _tagname;}
	virtual string getOpFormat()const{    return _tagformat;}
	virtual string getOpFilePos()const{   return LXS(size-written);}
	virtual string getOpFileName()const{  return _extname;}
	virtual string getOpFileIndex()const{ return "0";}
	virtual bool hasOpTag()const{        return true;}
	virtual bool hasOpFormat()const{     return true;}
	virtual bool hasOpFilePos()const{    return true;}
	virtual bool hasOpFileName()const{   return true;}
	virtual bool hasOpFileIndex()const{  return true;}


	virtual ~CopyOperation(){}

protected:
	CopyOperation(){}
	Storage* s1;
	Storage* s2;
	File* tagfile;
	File* extfile;
	size_t size;
	string extdev;
	volatile size_t curTagOffset;
	volatile size_t written;
	string _tagname;
	string _tagformat;
	string _extname;

};

#endif /* COPYOPERATION_H_ */
