// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef DUMPOPERATION_H_
#define DUMPOPERATION_H_

#include "ThreadOperation.h"

#define TRANSFER_SIZE 4194304lu

class DumpOperation: public ThreadOperation {
public:
	DumpOperation(size_t reference,
			Storage* s1, Storage* s2,
			File* tagfile, deque<File*> extfiles,
			const size_t offset, const size_t size,
			const size_t chunkSize,
			const string extdev):
		ThreadOperation("Dump",reference),
		s1(s1), s2(s2),
		tagfile(tagfile), extfiles(extfiles),
		size(size),
		chunkSize(chunkSize),
		extdev(extdev), curTagOffset(offset), written(0){

	}


	virtual void threadOpRun(){
		int         in_fd            = -1;
		int         out_fd           = -1;
		size_t      remaining        = 0;
		size_t      curTransferSize  = 0;
		int         res1             = 0;
		int         res2             = 0;
		size_t      bytes_read       = 0;
		size_t      bytes_written    = 0;
		TimeStamp   start            = __TimeStamp();
		TimeStamp   stop             = __TimeStamp();
		TimeStamp   delta            = __TimeStamp();
		TimeStamp   startChunk       = __TimeStamp();
		TimeStamp   stopChunk        = __TimeStamp();
		millisecond elapsed          = 0;
		double      bw               = 0;
		char*       buf              = (char*) malloc(TRANSFER_SIZE);
		size_t      sizeForThisChunk = 0;
		File*       tmp              = NULL;
		size_t      num_files        = extfiles.size();

		if (!buf){
			LOGC(L_ERROR, "[Dump] : Can't allocate transfer buffer.", OPERATION_ERROR_COLORS);
			goto cleanup_outer;
		}
		bzero((void*)buf,TRANSFER_SIZE);
		if (!tagfile){
			LOGC(L_ERROR, "[Dump] : Missing input file.", OPERATION_ERROR_COLORS);
			goto cleanup_outer;
		}
		if (!tagfile->isOpen()){
			LOGC(L_ERROR, "[Dump] : Input file not open.", OPERATION_ERROR_COLORS);
			goto cleanup_outer;
		}
		in_fd  = *(tagfile->getDescriptor());
		_tagname   = tagfile->getName();
		_tagformat = tagfile->getAttribute("OpFormat");

		start = Time::now();
		LOGC(L_INFO, "[Dump] : Starting operation " + Time::humanReadable(start), OPERATION_COLORS);

		while((!isInterrupted()) && (!extfiles.empty())){
			tmp = extfiles.front(); extfiles.pop_front();
			if (!tmp){
				LOGC(L_ERROR, "[Dump] : Missing output file "+LXS(current_file)+".", OPERATION_ERROR_COLORS);
				goto cleanup_inner_error;
			} else {
				if (current_file != (num_files-1))
					sizeForThisChunk = chunkSize;
				else
					sizeForThisChunk = (size-((num_files-1) * chunkSize));
				written=0;
				extfile = tmp;
			}

			if (!extfile->isOpen()){
				LOGC(L_ERROR, "[Dump] : Output file not open.", OPERATION_ERROR_COLORS);
				goto cleanup_inner_error;
			}
			_extname = extfile->getName();
			out_fd = *(extfile->getDescriptor());
			startChunk = Time::now();
			LOGC(L_INFO, "[Dump] : Starting chunk # " + LXS(current_file) +" ["+Storage::humanReadable(sizeForThisChunk)+"] @ " + Time::humanReadable(startChunk), OPERATION_COLORS);


			while((!isInterrupted()) && (written<sizeForThisChunk)){
				remaining    = sizeForThisChunk-written;
				curTransferSize = min(remaining,TRANSFER_SIZE);
				if ((size_t) lseek(in_fd,curTagOffset,SEEK_SET)!=curTagOffset){
					LOGC(L_ERROR, "[Dump] : Can't seek input file.", OPERATION_ERROR_COLORS);
					goto cleanup_inner_error;
				}

				res1 = ::read(in_fd,buf,curTransferSize);
				switch(res1){
				case  0: continue;
				case -1:
					if (errno == EAGAIN) continue;
					LOGC(L_ERROR, "[Dump] : Can't read from input chunk: '"+string(strerror(errno))+"'", OPERATION_ERROR_COLORS);
					goto cleanup_inner_error;
				default:
					bytes_read = (size_t) res1;
					if (!bytes_read) continue;
					break;
				}

				res2 = ::write(out_fd,buf,bytes_read);
				switch(res2){
				case  0: continue;
				case -1:
					if (errno == EAGAIN) continue;
					LOGC(L_ERROR, "[Dump] : Can't write to output chunk: '"+string(strerror(errno))+"'", OPERATION_ERROR_COLORS);
					goto cleanup_inner_error;
				default:
					bytes_written = (size_t) res2;
					curTagOffset += bytes_written;
					written      += bytes_written;
					written_total+= bytes_written;
					break;
				}
			}

			stopChunk = Time::now();
			LOGC(L_INFO, "[Dump] : Finishing chunk " + Time::humanReadable(stopChunk), OPERATION_COLORS);
			delta =Time::getTimeStampDelta(startChunk,stopChunk);
			elapsed = delta.MPM + (delta.MJD * MILLIS_PER_DAY) + 1;
			bw = ((double)written * 1000lu) / ((double)elapsed);
			LOGC(L_INFO, "[Dump] : Chunk offset:  " + Storage::humanReadable(written_total-written) , OPERATION_COLORS);
			LOGC(L_INFO, "[Dump] : Chunk volume:  " + Storage::humanReadable(written) , OPERATION_COLORS);
			LOGC(L_INFO, "[Dump] : Chunk time:    " + LXS(elapsed) + " ms" , OPERATION_COLORS);
			LOGC(L_INFO, "[Dump] : Chunk rate:    " + Storage::humanReadableBW(bw) , OPERATION_COLORS);
			goto cleanup_inner;
			cleanup_inner:
			{
				//LOGC(L_INFO, "[Dump] : Starting chunk cleanup", OPERATION_COLORS);
				if (extfile && extfile->isOpen()) extfile->close();
				if (s2 && extfile) s2->putFile(extfile);
				extfile = NULL;
				//LOGC(L_INFO, "[Dump] : Chunk cleanup complete.", OPERATION_COLORS);

			}
			current_file++;
			continue;

			cleanup_inner_error:
			{
				LOGC(L_INFO, "[Dump] : Starting chunk cleanup (error)", OPERATION_ERROR_COLORS);
				if (extfile && extfile->isOpen()) extfile->close();
				if (s2 && extfile) s2->putFile(extfile);
				extfile = NULL;
				while(!extfiles.empty()){
					tmp = extfiles.front();
					extfiles.pop_front();
					if (tmp && tmp->isOpen()) tmp->close();
					if (s2 && tmp) s2->putFile(tmp);
				}
				LOGC(L_INFO, "[Dump] : Chunk cleanup complete.", OPERATION_ERROR_COLORS);
				goto cleanup_outer;
			}


		}

		stop = Time::now();
		LOGC(L_INFO, "[Dump] : Finishing operation " + Time::humanReadable(stop), OPERATION_COLORS);
		delta =Time::getTimeStampDelta(start,stop);
		elapsed = delta.MPM + (delta.MJD * MILLIS_PER_DAY) + 1;
		bw = ((double)written_total * 1000lu) / ((double)elapsed);
		LOGC(L_INFO, "[Dump] : Dump volume:  " + Storage::humanReadable(written) , OPERATION_COLORS);
		LOGC(L_INFO, "[Dump] : Dump time:    " + LXS(elapsed) + " ms" , OPERATION_COLORS);
		LOGC(L_INFO, "[Dump] : Dump rate:    " + Storage::humanReadableBW(bw) , OPERATION_COLORS);


		cleanup_outer:
		LOGC(L_INFO, "[Dump] : Starting operation cleanup", OPERATION_COLORS);
		if (extfile){
			LOGC(L_WARNING, "[Dump] : External file not NULL at cleanup. Were we stopped?", OPERATION_ERROR_COLORS);
			if (extfile && extfile->isOpen()) extfile->close();
			if (s2 && extfile) s2->putFile(extfile);
		}
		if (!extfiles.empty()){
			LOGC(L_WARNING, "[Dump] : External file vector not empty at cleanup. Were we stopped?", OPERATION_ERROR_COLORS);
			while(!extfiles.empty()){
				tmp = extfiles.front();
				extfiles.pop_front();
				if (tmp && tmp->isOpen()) tmp->close();
				if (s2 && tmp) s2->putFile(tmp);
			}
		}
		if (buf) free(buf);
		if (tagfile && tagfile->isOpen()) tagfile->close();
		if (s1 && tagfile) s1->putFile(tagfile);
		LOGC(L_INFO, "[Dump] : Operation cleanup complete.", OPERATION_COLORS);

	}

	virtual bool threadOpCancel(bool started){
		doAbort();
		return true;
	}
	virtual string getOpTag()const{       return _tagname;}
	virtual string getOpFormat()const{    return _tagformat;}
	virtual string getOpFilePos()const{   return LXS(size-written_total);}
	virtual string getOpFileName()const{  return _extname;}
	virtual string getOpFileIndex()const{ return "0";}

	virtual bool hasOpTag()const{        return true;}
	virtual bool hasOpFormat()const{     return true;}
	virtual bool hasOpFilePos()const{    return true;}
	virtual bool hasOpFileName()const{   return true;}
	virtual bool hasOpFileIndex()const{  return true;}


	virtual ~DumpOperation(){}

protected:
	DumpOperation(){}
	Storage* s1;
	Storage* s2;
	File* tagfile;
	File* extfile;
	deque<File*> extfiles;
	size_t size;                        // total number of bytes
	size_t chunkSize;                   // bytes for each file chunk
	string extdev;
	volatile size_t curTagOffset;       // current offset within the tag file
	volatile size_t written;            // written in the current chunk
	volatile size_t written_total;      // written total
	volatile size_t current_file;       // # 0..N
	string _tagname;
	string _tagformat;
	string _extname;

};


#endif /* DUMPOPERATION_H_ */
