// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#ifndef DRXSPECTROMETER_H_
#define DRXSPECTROMETER_H_

#include "../Buffers/ObjectBuffer.hpp"
#include "../Streaming/Plugin.h"
#include "../Streaming/TicketBuffer.h"
#include "../System/PeriodicReportTimer.h"
#include "Spectrometer.h"
#include "TestPattern.h"

// do we do sample unpacking on the fly, or use look up tables?
//#define USE_LUTS
#define DRX_SPECTROMETER_REPORT_INTERVAL 30000
#define DRX_SPECTRA_MAGIC1 0xC0DEC0DE
#define DRX_SPECTRA_MAGIC2 0xED0CED0C

typedef struct __DrxSpectraHeader{
	uint32_t			MAGIC1;     // must always equal 0xC0DEC0DE
	uint64_t 			timeTag0;
	uint16_t 			timeOffset;
	uint16_t 			decFactor;
	uint32_t 			freqCode[2];
	uint32_t			fills[4];
	uint8_t				errors[4];
	uint8_t 			beam;
	uint8_t         stokes_format;
	uint8_t             spec_version;
	union{
		struct {
			uint8_t     flag_xcp:1;
			uint8_t     flag_reserved:5;
			uint8_t     flag_k:2; // kurtosis
		};
		uint8_t         reserved;
	};
	union{
		uint32_t 			nFreqs;
		uint32_t 			nPerFrame;
	};
	uint32_t 			nInts;
	uint32_t 			satCount[4];
	uint32_t			MAGIC2;     // must always equal 0xED0CED0C
} __attribute__((packed)) DrxSpectraHeader;

enum DrxComp{ BEFORE, COMPAT_BEFORE, COMPAT_IN, COMPAT_AFTER, INCOMPAT };
enum DrxBlockState{ BS_UNUSED=0, BS_FILLING, BS_STARTABLE, BS_PROCESSING, BS_DONE, BS_DROPPED};
#define FREQ_CODE_UNINITIALIZED (uint32_t)0xFEEDBEEF
#define DRX_TUN_0 1
#define MAX_SIMULTANEOUS_BLOCKS_PROCESSING 1

enum BlockStages {FILLING, PROCESSING, DONE}; // implicit invalid stage

typedef struct __DrxBlockSetup{
	__DrxBlockSetup():
		//state(BS_EMPTY),
		//spc_block_index(0),
		//ticketFrameIndex(0),
		bIdx((size_t)(-1ll)),
		timeTag0(0),
		timeTagN(0),
		stepPhase(0),
		timeTagStep(0),
		decFactor(0),
		timeOffset(0),
		beam(0),
		freqCode()
		{
		freqCode[0]=FREQ_CODE_UNINITIALIZED;
		freqCode[1]=FREQ_CODE_UNINITIALIZED;
	}
	DrxBlockState       state;
	size_t              bIdx; // block index into the spectrometer buffer
	uint64_t 			timeTag0;
	uint64_t 			timeTagN;
	uint64_t 			stepPhase;
	uint64_t 			timeTagStep;
	uint16_t 			decFactor;
	uint16_t 			timeOffset;
	uint8_t 			beam;
	uint32_t 			freqCode[2];
//	bool                ownsTicketFrame;
	uint64_t 			insertionCount;
	DrxSpectraHeader*   header;
	float*              data;
	bool                error;
}__attribute__((packed))  DrxBlockSetup;

typedef struct __SpectrometerCounters{
	uint32_t				framesReceived;
	uint32_t				framesInserted;
	uint32_t				framesInsertedExisting;
	uint32_t				framesInsertedNew;
	uint32_t				framesInsertedFresh;
	uint32_t				framesInsertedStale;
	uint32_t				framesDroppedArrivedLate;
	uint32_t				framesDroppedArrivedLate_alt;
	uint32_t				framesDroppedIncompatible;
	uint32_t				framesStalledWaitingBlock;
	uint32_t				framesStalledBlockUnstartable;

	uint32_t				blocksStarted;
	uint32_t				blocksStartedFull;
	uint32_t				blocksStartedHighWater;
	uint32_t				blocksDropped;
	uint32_t				blocksDroppedUnderfull;
	uint32_t				blocksCompleted;

	uint32_t				checkBlockDone_Done;
	uint32_t				checkBlockDone_NotDone;
	uint32_t				checkBlockDone_NotComputing;
	uint32_t				checkBlockDone_WaitFree;
	uint32_t				checkBlockDone_Error;
	uint32_t				checkBlockStart_WaitOutbuf;

	uint32_t				illegalFrames;
	uint32_t				incompatibleFrames;

	/*
	uint32_t				checkCleanup;
	uint32_t				checkCleanup_WasDropped;
	uint32_t				checkCleanup_WasDone;
	uint32_t				checkBlockDone_WasDropped;
	uint32_t				checkBlockStart_nothingActionable;
	uint32_t				checkBlockStart_WasDropped;
	uint32_t				checkBlockStart_WasFilling;
	uint32_t				checkBlockStart_WaitComputers;
	uint32_t				checkBlockStart_WaitOutbuf;
	*/

} __attribute__((packed)) SpectrometerCounters;

class DrxSpectrometer: public Plugin {
public:

	DrxSpectrometer(unsigned K, unsigned L, unsigned Nb, ProductType _OutT, TicketBuffer*& _source );
	virtual ~DrxSpectrometer();

	// external interface
	bool         isShutDown();
	bool         isValid();
	virtual void stopProducing();
	virtual void stopReceiving();


	// the input/output threads
	virtual void run_master();
	virtual void run_slave();

	// input-thread methods
	bool     insert(DrxFrame* f);
	uint64_t nextTimeTagAfterBlock(DrxBlockSetup* bs);
	void     initBlockSetup(DrxBlockSetup* toPrepare, DrxFrame* f, DrxBlockSetup* predecessor = NULL);
	bool     blockMatch(DrxFrame* f, DrxBlockSetup* bs);
	int      compare(DrxFrame* f, DrxBlockSetup* bs);
	bool     unpack(DrxFrame* f, DrxBlockSetup* bs);
	bool     frameIsLegal(DrxFrame* f);

	// output-thread methods
	void startBlock(DrxBlockSetup* bs, DrxSpectraHeader* dsh, float* aData);
	bool isDoneOrError(DrxBlockSetup* bs);
	bool isError(DrxBlockSetup* bs);
	void initSpectraHeader(DrxBlockSetup* bs, DrxSpectraHeader* dsh);
	void resetBlockSetup(DrxBlockSetup* bs);

	// miscellaneous; help with object buffer manipulation, since we effectively want moves to be atomic (though they aren't, really, but are safe for single producer, single consumer)
	bool canMove(ObjectBuffer<DrxBlockSetup*>* from, ObjectBuffer<DrxBlockSetup*>* to); // checks if the head of from is movable to the tail of to
	void doMove(ObjectBuffer<DrxBlockSetup*>* from,  ObjectBuffer<DrxBlockSetup*>* to); // moves the head of from to the tail of to
	bool canRemove(ObjectBuffer<DrxBlockSetup*>* from);
	bool canInsert(ObjectBuffer<DrxBlockSetup*>* to);

	string getObjName();

	// reporting, runtime, stats, and debugging
	SpectrometerCounters* getCounters();
	void   printSpecSetup();
	void   printBlockSetup(DrxBlockSetup* bs);
	void   printFrameSetup(DrxFrame* f, DrxBlockSetup* bs=NULL);
	string specReport();
	//void   generateTestPattern(float* specdata);
	void   doPeriodicReport();


	/*
	virtual void stopProducing();
	virtual bool isShutDown();
	virtual bool isValid();
	virtual bool monitor();

	void handleInsertion(TicketBuffer::Ticket* t_in, size_t& cur_in_next, size_t& cur_in_done);
	void handleBlockCleanup(TicketBuffer::Ticket* t_out, size_t& cur_out_next, size_t& cur_out_done);
	void generateTestPattern(float* specdata);
	void waitNoComputeThreadsActive();
	void handleBlockMonitoring();
	void handleBlockStarting(TicketBuffer::Ticket* t_out, size_t& cur_out_next, size_t& cur_out_done);
	void initSpectraHeader(DrxBlockSetup* bs, DrxSpectraHeader* dsh);
	bool insertFrame(DrxFrame* f);
	void initBlockSetup(DrxBlockSetup* toPrepare, DrxFrame* f, DrxBlockSetup* predecessor);
	void initBlockSetup(DrxBlockSetup* toPrepare, DrxFrame* f);
	DrxComp compareBlockAndFrame(DrxFrame* f, DrxBlockSetup* bs);
	void insert(DrxFrame* f, DrxBlockSetup* bs);
	SpectrometerCounters* getCounters();
	double getRuntime();
	void printBlockSetup(DrxBlockSetup* bs);
	void printFrameSetup(DrxFrame* f, DrxBlockSetup* bs=NULL);
	string specReport();
*/
private:
	bool 						 valid;                         // flag indicating all data structures are initialized properly
	volatile bool                doneReceiving;                 // flag indicating we are to stop receiving data
	volatile bool                doneProducing;                 // flag indicating we are to stop producing data
	volatile bool                master_stopped;                // flag indicating receiver thread is terminated
	volatile bool                slave_stopped;                 // flag indicating computer thread is terminated

	DrxBlockSetup*               blocks;                        // buffer to hold all the blocks
	ObjectBuffer<DrxBlockSetup*> blocks_free;					// all start here
	ObjectBuffer<DrxBlockSetup*> blocks_startable;				// blocks that have finished filling
	ObjectBuffer<DrxBlockSetup*> blocks_dropped;                // blocks dropped
	ObjectBuffer<DrxBlockSetup*> blocks_computing;              // blocks in progcess of computing
	list<DrxBlockSetup*>         blocks_filling;				// blocks that have started filling
	DrxBlockSetup                lastFilledBlockSetup;          // cached copy of most-recently-filled block setup
	bool						 lastFilledBlockSetupGood;      // flag indicating cached copy is good (initialized)

	Spectrometer*                spc;                           // our spectrometer buffer/obj
	TicketBuffer*                source;                        // out input buffer (mainly used through plugin interface)
	unsigned                     freqCount_or_samp_per_frame;   // number of frequency channels
	unsigned                     intCount;                      // number of integrations
	unsigned                     blockCount;                    // number of blocks (both block info and spectrometer obj (linked))
	ProductType                  OutT;                          // output format
	volatile bool                _is_shutdown;                  // flag indicating we're shutdown (so don't free any more resources)
	SpectrometerCounters         counters;                      // statictics

	size_t                       minTimeTag;                    // earliest legal time tag an input frame can have
	PeriodicReportTimer          rptTimer;





	size_t					     outputHeaderSize;              // size of header
	size_t					     outputDataSize;                // size of spectra
	size_t					     outputBlockSize;               // size of spectra+header
	size_t					     inputFramesPerCell;
	size_t					     inputFramesPerBlock;

/////////////////////////////////////////////////////////////////////
// Static interface                                                //
/////////////////////////////////////////////////////////////////////
public:
	static TB_Geometry getDrxBufferSize(unsigned K, ProductType OutT);
private:
	static unsigned char SatLUT[256]; // 1 for all 8-bit indices whose packed interpretation represents a saturated sample
	static bool          LUT_initialized;
	#ifdef USE_LUTS
	static fftwf_complex LUT[256];    // precomputed unpacking of 8-bit(4i+4q) to complex type
	#endif
	// always use sat LUTs
	static void initLookUpTables();
};
#endif /* DRXSPECTROMETER_H_ */
