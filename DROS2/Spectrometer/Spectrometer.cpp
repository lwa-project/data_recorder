// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "Spectrometer.h"

string stokesName(StokesProduct s){
	switch(s){
		case XX:       return "XX";
		case XY:       return "XY";
		case YX:       return "YX";
		case YY:       return "YY";
		case XXYY:     return "XXYY";
		case XXXYYXYY: return "XXXYYXYY";
		case I:        return "I";
		case Q:        return "Q";
		case U:        return "U";
		case V:        return "V";
		case IV:       return "IV";
		case IQUV:     return "IQUV";
		default:	   return "Unknown stokes mode";
	}
}

StokesProduct nameToStokes(string name){
	if (!strcmp(name.c_str(),"XX"))       return XX;
	if (!strcmp(name.c_str(),"XY"))       return XY;
	if (!strcmp(name.c_str(),"YX"))       return YX;
	if (!strcmp(name.c_str(),"YY"))       return YY;
	if (!strcmp(name.c_str(),"XXYY"))     return XXYY;
	if (!strcmp(name.c_str(),"XXXYYXYY")) return XXXYYXYY;
	if (!strcmp(name.c_str(),"I"))        return I;
	if (!strcmp(name.c_str(),"Q"))        return Q;
	if (!strcmp(name.c_str(),"U"))        return U;
	if (!strcmp(name.c_str(),"V"))        return V;
	if (!strcmp(name.c_str(),"IV"))       return IV;
	if (!strcmp(name.c_str(),"IQUV"))     return IQUV;
	return INVALID_STOKES;
}

void* __FftWrapper(ThreadInfo* td){
	//LOG(L_DEBUG, "__FftWrapper " + LXS(td->bIdx));
	//LOGC(L_FATAL, "FFT THREAD STARTED #"+LXS(td->threadIdx), bold, black, green );
	td->spec->doFft(td->bIdx,td->threadIdx);
	return NULL;
}

inline void cplx_mult(complex_pair* a, complex_pair* b, complex_pair* res){
	complex_pair neg_imag;
	((float*)&neg_imag)[0] =  1.0;
	((float*)&neg_imag)[1] = -1.0;
	((float*)&neg_imag)[2] =  1.0;
	((float*)&neg_imag)[3] = -1.0;

	// real part
	complex_pair tmp1  = __builtin_ia32_mulps( *a,*b);                      //(re*re,im*im)
	             tmp1  = __builtin_ia32_mulps( tmp1,neg_imag);              //(re*re,-im*im)

	// imag part
    complex_pair tmp_s = __builtin_ia32_shufps(*b,*b,_MM_SHUFFLE(1,0,3,2)); // swap real/imag
    complex_pair tmp2  = __builtin_ia32_mulps( tmp_s,*a);                   // (re*im, re*im)

	*res = __builtin_ia32_haddps(tmp1, tmp2);

}
inline void cplx_mag_pre(complex_pair* a, complex_pair* b, complex_pair* res){
	// a    = [x0r,x0i,x1r,x1i]; i.e. [X0,X1]
	// b    = [y0r,y0i,y1r,y1i]; i.e. [Y0,Y1]
	// tmp1 = [x0r^2, x0i^2, x1r^2, x1i^2];
	// tmp2 = [y0r^2, y0i^2, y1r^2, y1i^2]];
	// *res = [x0r^2 + x0i^2 , x1r^2 + x1i^2     ,     y0r^2 + y0i^2,  y1r^2 + y1i^2 ];
	//   i.e. --> [|X0|, |X1|, |Y0|, |Y1|];
	complex_pair tmp1  = __builtin_ia32_mulps( *a,*a);
	complex_pair tmp2  = __builtin_ia32_mulps( *b,*b);
	*res               = __builtin_ia32_haddps(tmp1, tmp2);
}

inline void cplx_mag_sum(complex_pair* mag_pre, float* out1, float* out2){
	*out1 = ((float*)mag_pre)[0]+((float*)mag_pre)[2];
	*out2 = ((float*)mag_pre)[1]+((float*)mag_pre)[3];
}

inline void cplx_mag_dif(complex_pair* mag_pre, float* out1, float* out2){
	*out1 = ((float*)mag_pre)[0]-((float*)mag_pre)[2];
	*out2 = ((float*)mag_pre)[1]-((float*)mag_pre)[3];
}


inline void cplx_conj(complex_pair* in, complex_pair* out){
	complex_pair neg_imag;
	((float*)&neg_imag)[0] =  1.0;
	((float*)&neg_imag)[0] = -1.0;
	((float*)&neg_imag)[0] =  1.0;
	((float*)&neg_imag)[0] = -1.0;
	*out = __builtin_ia32_mulps( *in,neg_imag);
}


