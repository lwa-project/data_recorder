// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef SPECTROMETER_H_
#define SPECTROMETER_H_
//#ifdef DEBUG_SPEC
	#include <cassert>
//#else
	//#define assert(...)
//#endif




#include <immintrin.h>

#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <strings.h>
#include <fftw3.h>
#include "../Primitives/StdTypes.h"
#include "../Data/LwaDataFormats.h"
#include "../Common/branchPredict.h"
#include "../Threading/LockHelper.h"
#include "../System/Log.h"

enum Pol{POL_X=0,POL_Y=1};

enum PolType{ X=0x01, Y=0x02, XandY=0x03};
#define PolSize(p) (__builtin_popcount(p))

enum SamplePolOrganization{ Interleaved, Noninterleaved};

enum StokesProduct {
	INVALID_STOKES = 0x00,
	XX   = 0x01, XY       = 0x02, YX = 0x04, YY   = 0x08,
	I    = 0x10, Q        = 0x20, U  = 0x40, V    = 0x80,
	XXYY = 0x09, XXXYYXYY = 0x0F, IV = 0x90, IQUV = 0xF0
}; // thanks Jake :)
#define StokesSize(s) (__builtin_popcount(s))
string stokesName(StokesProduct s);
StokesProduct nameToStokes(string name);
#define StokesSupported(s)\
	((s==XXYY)||\
	 (s==IQUV)||\
	 (s==IV)\
	 /* more here as supported */\
	)
#define StokesTypeLegalOnInputType(s,p)\
	(\
		(s==XX && (p!=Y)) ||\
		(s==YY && (p!=X)) ||\
		(p==XandY)\
	)



enum CorrProduct{
	cINVALID = 0x00,
	cXY      = 0x02
};
#define CorrSize(c) (__builtin_popcount(c))
string corrName(CorrProduct c);
CorrProduct   nameToCorr(string name);
#define CorrSupported(c)\
	((c==cXY)\
	 /* more here as supported */\
	)
#define CorrTypeLegalOnInputType(c,p)\
	(\
		((c==cXY)&&(p==XandY))\
	)


typedef struct __ProductType{
	__ProductType(StokesProduct s):stokes(s),isCorr(false){};
	__ProductType(CorrProduct c):corr(c),isCorr(true){};
	StokesProduct toStokes(){             return isCorr ? INVALID_STOKES : stokes;}
	CorrProduct   toCorr(){               return isCorr ? corr           : cINVALID;}
	bool legalForInputType(PolType pin){  return isCorr ? (CorrTypeLegalOnInputType(corr, pin)) : (StokesTypeLegalOnInputType(stokes,pin));}
	bool isSupported(){                   return isCorr ? (CorrSupported(corr))                 : (StokesSupported(stokes));}
	size_t numberOutputProducts(){        return isCorr ? CorrSize(corr)                        : StokesSize(stokes);}
	bool   outputProductsComplex(){       return isCorr;}
	string name(){                        return isCorr ? corrName(corr) : stokesName(stokes);}
	union{
		StokesProduct stokes;
		CorrProduct corr;
		uint8_t byte;
	};
	bool isCorr;
}ProductType;
#define ProductSize(p) (__builtin_popcount(p.byte))




class Spectrometer;
typedef struct __BlockInfo{
	boost::barrier* fftBarrier;
	boost::barrier* accBarrier;
	volatile bool done;                      // flag indicating acc phase is complete
	bool          error;
}BlockInfo;

typedef struct __ThreadInfo{
	pthread_t     thread;
	Spectrometer* spec;
	unsigned      bIdx;
	unsigned      threadIdx;
}ThreadInfo;




void* __ThreadWrapper(ThreadInfo* td);

typedef void*(*threadFunc)(void*);


#ifdef VERIFY_VECTOR_OPS
	#define ASSERT_BUILTIN_V_OP(a, b, c, op)\
		{\
			float* __c = (float*)&(c);\
			float* __a = (float*)&(a);\
			float* __b = (float*)&(b);\
			for (int qq = 0; qq<4; qq++){\
				assert(__c[qq] == (__a[qq] op __b[qq]));\
			}\
		}
	#define ASSERT_BUILTIN_V_H_OP(a, b, c, op)\
			{\
				float* __c = (float*)&(c);\
				float* __a = (float*)&(a);\
				float* __b = (float*)&(b);\
				for (int qq = 0; qq<2; qq++){\
					assert(__c[qq] == (__a[qq*2] op __a[(qq*2)+1]));\
				}\
				for (int qq = 2; qq<4; qq++){\
					assert(__c[qq] == (__b[(qq-2)*2] op __b[((qq-2)*2)+1]));\
				}\
			}

	#define ASSERT_BUILTIN_MULPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, *)
	#define ASSERT_BUILTIN_ADDPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, +)
	#define ASSERT_BUILTIN_SUBPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, -)
	#define ASSERT_BUILTIN_HADDPS(a,b,c) ASSERT_BUILTIN_V_H_OP(a, b, c, +)
	#define ASSERT_BUILTIN_HSUBPS(a,b,c) ASSERT_BUILTIN_V_H_OP(a, b, c, -)
	#define ASSERT_SHUFFLE(a,b,c,i0,i1,i2,i3)\
		{\
			float* __c = (float*)&(c);\
			float* __a = (float*)&(a);\
			float* __b = (float*)&(b);\
			LOG_START_SESSION(L_DEBUG);\
			for (int qq=0; qq<4; qq++){\
				cout << setw(12) << __a[qq] << setw(12) << __b[qq] << setw(12) << "..." << __c[qq] << endl;\
			}\
			LOG_END_SESSION();\
			assert(__c[0] == __a[i3]);\
			assert(__c[1] == __a[i2]);\
			assert(__c[2] == __b[i1]);\
			assert(__c[3] == __b[i0]);\
		}
#else
	#define ASSERT_BUILTIN_V_OP(a, b, c, op)
	#define ASSERT_BUILTIN_V_H_OP(a, b, c, op)
	#define ASSERT_BUILTIN_MULPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, *)
	#define ASSERT_BUILTIN_ADDPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, +)
	#define ASSERT_BUILTIN_SUBPS(a,b,c)  ASSERT_BUILTIN_V_OP(a, b, c, -)
	#define ASSERT_BUILTIN_HADDPS(a,b,c) ASSERT_BUILTIN_V_H_OP(a, b, c, +)
	#define ASSERT_BUILTIN_HSUBPS(a,b,c) ASSERT_BUILTIN_V_H_OP(a, b, c, -)
	#define ASSERT_SHUFFLE(a,b,c,i0,i1,i2,i3)
#endif






class Spectrometer {
public:


	Spectrometer(unsigned K, unsigned L, unsigned Ns, unsigned Nb, PolType InT, SamplePolOrganization InO, ProductType OutT):
	valid(false),
	XY_interlaced(InO == Interleaved),
	//barrierSyncRequired(needsBarrierSync(OutT)),
	outputType(OutT),
	k((int)K),
	l((int)L),
	// general geometry
	number_products(OutT.numberOutputProducts()),
	number_cells(PolSize(InT)),
	number_streams(Ns),
	number_blocks(Nb),

	number_threads(number_cells * number_streams),

	total_cells(number_cells * number_streams * number_blocks),
	total_products(number_products * number_streams * number_blocks),

	// Cell/stream/block geometry
	samples_per_cell(K*L),
	samples_per_stream(samples_per_cell * number_cells),
	samples_per_block(samples_per_stream * number_streams),
	samples_per_buf(samples_per_block * number_blocks),

	// accumulator geometry
	// [block][]
	osamples_per_product(K),
	osamples_per_stream(osamples_per_product * number_products),
	osamples_per_block(osamples_per_stream * number_streams),
	osamples_per_buf(osamples_per_block * number_blocks),


	plans(NULL),
	idata(NULL),
	odata(NULL),
	adata(NULL),
	fills(NULL),
	sat_counts(NULL),
	bInfo(NULL),
	tInfo(NULL),
	reason("")

	{

		if (!OutT.isSupported()){
			reason="Unsupported output type";
			return;
		}

		if (!OutT.legalForInputType(InT)){
			reason="Illegal combination of input and output formats";
			return;
		}

		if (XY_interlaced){
			reason="Unsupported input pol arrangement";
			return;
		}

		reason = "Can't initialize thread attributes.\n";
		// set our launch attributes
		if (pthread_attr_init(&attr)){
			return ;
		}
		if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE)){
			pthread_attr_destroy(&attr);
			return;
		}
		if (pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM)){
			pthread_attr_destroy(&attr);
			return;
		}
		if (pthread_attr_setschedpolicy(&attr, SCHED_FIFO)){
			pthread_attr_destroy(&attr);
			return;
		}

		reason="Memory allocation failure"; // just in case

		// allocate input data
		idata = fftwf_alloc_complex(samples_per_buf);
		if (! idata){
			uninit(); return;
		}
		bzero((void*)idata,samples_per_buf*sizeof(fftwf_complex));

		// allocate output data
		odata = fftwf_alloc_complex(samples_per_buf);
		if (! odata){
			uninit(); return;
		}
		bzero((void*)odata,samples_per_buf*sizeof(fftwf_complex));

		// allocate accumulator data ( to be provided at time of computation )
		adata = (float**) malloc(number_blocks*sizeof(float*));
		if (! adata){
			uninit(); return;
		}
		bzero((void*)adata,number_blocks*sizeof(float*));



		// allocate cell fill counts
		fills = (size_t *) malloc(total_cells * sizeof(size_t));
		if (! fills){
			uninit(); return;
		}
		bzero((void*)fills,total_cells*sizeof(size_t));

		// allocate cell saturation counts
		sat_counts = (size_t *) malloc(total_cells * sizeof(size_t));
		if (! sat_counts){
			uninit(); return;
		}
		bzero((void*)fills,total_cells*sizeof(size_t));

		// allocate plans
		plans = (fftwf_plan *) malloc(total_cells * sizeof(fftwf_plan));
		if (! plans){
			uninit(); return;
		}
		bzero((void*)plans,total_cells*sizeof(fftwf_plan));

		// allocate block info structures to pass to the threads
		bInfo = (BlockInfo *) malloc(number_blocks * sizeof(BlockInfo));
		if (!bInfo){
			uninit(); return;
		}
		bzero((void*)bInfo,number_blocks * sizeof(BlockInfo));


		tInfo = (ThreadInfo *) malloc(number_threads * number_blocks * sizeof(ThreadInfo));
		if (!tInfo){
			uninit(); return;
		}
		bzero((void*)tInfo,number_threads * number_blocks * sizeof(ThreadInfo));


		// set everything up
		for (size_t b=0; b<number_blocks; b++){
			bzero((void*)&bInfo[b], sizeof(BlockInfo));
			bInfo[b].fftBarrier = new boost::barrier(number_threads);
			if (!bInfo[b].fftBarrier){
				LOGC(L_FATAL, "Failed to allocate fftBarrier for thread", bold, black, yellow);
				uninit(); return;
			}

			bInfo[b].accBarrier = new boost::barrier(number_threads);
			if (!bInfo[b].accBarrier){
				LOGC(L_FATAL, "Failed to allocate accBarrier for thread", bold, black, yellow);
				uninit(); return;
			}
			bInfo[b].done       = false;
			bInfo[b].error      = false;

			for (size_t s=0; s<number_streams; s++){
				// per cell initializations
				for (size_t c=0; c<number_cells; c++){
					size_t c_linear     = cellIndex(b,s,c);
					size_t c_data_index = c_linear * samples_per_cell;
					if (!outputType.isCorr){
						plans[c_linear] = fftwf_plan_many_dft(
								1, &k, l,
								&idata[c_data_index], NULL, 1, k,
								&odata[c_data_index], NULL, 1, k,
								FFTW_FORWARD, FFTW_ESTIMATE
						);
					}
					clearCellInput(c_linear);
					clearCellOutput(c_linear);
					clearCellCounters(c_linear);
				}
				for (size_t t=0; t<number_threads; t++){
					size_t t_linear = (b * number_threads) + t;
					tInfo[t_linear].thread    = (pthread_t) 0;
					tInfo[t_linear].spec      = this;
					tInfo[t_linear].bIdx      = b;
					tInfo[t_linear].threadIdx = t;
				}
			}
		}
		reason = "Successfully initialized";
		valid = true;
		return;
	}
	void uninit(){
		if (valid){
			for (size_t b=0; b<number_blocks; b++){
				if (bInfo[b].fftBarrier){
					delete (bInfo[b].fftBarrier);
					bInfo[b].fftBarrier = NULL;
				}
				if (bInfo[b].accBarrier){
					delete (bInfo[b].accBarrier);
					bInfo[b].accBarrier = NULL;
				}
				for (size_t s=0; s<number_streams; s++){
					for (size_t c=0; c<number_cells; c++){
						size_t c_linear     = cellIndex(b,s,c);
						if (!outputType.isCorr){
							fftwf_destroy_plan(plans[c_linear]);
						}
					}
				}
			}
		}
		if(idata){      fftwf_free(idata); idata      = NULL;}
		if(odata){      fftwf_free(odata); odata      = NULL;}
		if(adata){      free(adata);       adata      = NULL;}
		if(fills){      free(fills);       fills      = NULL;}
		if(sat_counts){ free(sat_counts);  sat_counts = NULL;}
		if(plans){      free(plans);       plans      = NULL;}
		if(bInfo){      free(bInfo);       bInfo      = NULL;}
		if(tInfo){      free(tInfo);       tInfo      = NULL;}
		pthread_attr_destroy(&attr);
		valid = false;

	}
	virtual ~Spectrometer(){
		uninit();
	}


	void startBlock(unsigned bIdx, float* adataPtr){
		assert(bIdx < number_blocks);
		assert(adataPtr != NULL);
		bInfo[bIdx].done       = false;
		bInfo[bIdx].error      = false;
		adata[bIdx]            = adataPtr;		for (unsigned i=0; i<number_threads; i++){
			unsigned t_linear = (bIdx*number_threads)+i;
			if (pthread_create(&tInfo[t_linear].thread,&attr, (threadFunc)__ThreadWrapper, &tInfo[t_linear]) != 0 ){
				do {
					pthread_cancel(tInfo[t_linear].thread);
					cout << "cancel\n";
				} while (i!=0);
				bInfo[bIdx].done       = true;
				bInfo[bIdx].error      = true;
				return;
			}
		}
	}

	bool isBlockDone(unsigned bIdx){
		return bInfo[bIdx].done;
	}
	bool isBlockError(unsigned bIdx){
		return bInfo[bIdx].error;
	}

	void waitBlock(unsigned bIdx){
		assert(bIdx < number_blocks);		if (!bInfo[bIdx].error){
			for (unsigned i=0; i<number_threads; i++){
				unsigned t_linear = (bIdx*number_threads)+i;
				pthread_join(tInfo[t_linear].thread, NULL);
				tInfo[t_linear].thread = (pthread_t)0;
			}
		}
	}

	void resetBlock(unsigned bIdx){
		assert(bIdx < number_blocks);		for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
			for (unsigned cur_c=0; cur_c<number_cells; cur_c++){
				size_t ci = cellIndex(bIdx,cur_str,cur_c);
				clearCellCounters(ci);
				clearCellInput(ci); // done in fft thread
			}
		}

	}

	// compute the fft for the cell identified by thread/block indices
	void doFft(unsigned bIdx,unsigned threadIndex){
		//static float s=0;
		assert(bIdx < number_blocks);		unsigned sIdx = threadIndex / number_cells;
		unsigned pIdx = threadIndex % number_cells;
		unsigned cIdx = cellIndex(bIdx, sIdx, pIdx);
		assert(cIdx < total_cells);
		if (!outputType.isCorr){
			fftwf_execute(plans[cIdx]);
			//clearCellInput(cIdx);
			//clearCellOutput(cIdx);
			//genTestXXYY(cIdx);
			//if (barrierSyncRequired)
			if(bInfo[bIdx].fftBarrier->wait()){
				// nada
			}
		}
		//bInfo[bIdx].fftBarrier->wait();
		doAcc(bIdx, threadIndex);
		if (bInfo[bIdx].accBarrier->wait()){
			bInfo[bIdx].done = true;
		}
	}
/*
	void genTestXXYY(unsigned cIdx){

		fftwf_complex* d = getCellOdata(cIdx);
		for (int i=0; i<l; i++)
			if (i==0){
				for (int f=0; f<k; f++)
					if (cIdx & 1){
						d[f+(i*k)][0] = 0;
						d[f+(i*k)][1] = 0;
					}else{
						d[f+(i*k)][0] = 0;
						d[f+(i*k)][1] = 0;
					}
			} else {
				for (int f=0; f<k; f++){
					d[f+(i*k)][0] = 0;
					d[f+(i*k)][1] = 0;
				}
			}
	}
*/
#define UNSUPPORTED_MODE() \
	{\
		LOGC(L_WARNING, "Program error: Spectrometer executing unsupported mode.", FATAL2_COLORS);\
		bInfo[bIdx].done=true;\
		return;\
	}

	// accumulate results for the given block, assuming the cells have been calculated
	void doAcc(unsigned bIdx,unsigned threadIndex){
		assert(bIdx < number_blocks);
		if (outputType.isCorr){
			switch (outputType.toCorr()){
				case cXY:		doAcc_c_XY(bIdx,threadIndex); break;
				default:		UNSUPPORTED_MODE(); break;
			}
		} else {
			switch (outputType.stokes){
				case XXYY:	    doAcc_XXYY(bIdx,threadIndex); break;
				case IQUV:      doAcc_IQUV(bIdx,threadIndex); break;
				case IV:		doAcc_IV(bIdx,threadIndex); break;
				case XX: 		doAcc_XX(bIdx,threadIndex); break;
				case XY: 		doAcc_XY(bIdx,threadIndex); break;
				case YX: 		doAcc_YX(bIdx,threadIndex); break;
				case YY: 		doAcc_YY(bIdx,threadIndex); break;
				case XXXYYXYY:	doAcc_XXXYYXYY(bIdx,threadIndex); break;
				case I:			doAcc_I(bIdx,threadIndex); break;
				case Q:			doAcc_Q(bIdx,threadIndex); break;
				case U:			doAcc_U(bIdx,threadIndex); break;
				case V:			doAcc_V(bIdx,threadIndex); break;
				default:		UNSUPPORTED_MODE(); break;
			}
		}

	}

	void doAcc_XX(       unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_XY(       unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_YX(       unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_YY(       unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_XXYY(     unsigned bIdx,unsigned threadIndex){
		// input stepping
		unsigned n_freqs_per_thread = k/number_threads;                  // units of complex
		unsigned startFreq          = threadIndex * n_freqs_per_thread;  // units of complex
		unsigned stopFreq           = startFreq + n_freqs_per_thread;
		unsigned intStep            = k;                                 // units of complex
		// output stepping
		unsigned fStep              = number_products;
		for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
			// where is x starting from?
			unsigned cIdx_x       = cellIndex(bIdx, cur_str, POL_X); //assert(cIdx_x < total_cells);
			fftwf_complex* x_base = getCellOdata(cIdx_x);
			__v4sf* x             = (__v4sf*) x_base;

			// where is y starting from?
			unsigned cIdx_y       = cellIndex(bIdx, cur_str, POL_Y); //assert(cIdx_y < total_cells);
			fftwf_complex* y_base = getCellOdata(cIdx_y);
			__v4sf* y             = (__v4sf*) y_base;

			// where does data for the block go?
			float* a_base = adata[bIdx];
			float* a_str  = &a_base[k*number_products*cur_str];

			// flip L-R
			unsigned freq_mask = k>>1;

			// pre-zero the accumulator
			bzero((void*) &a_str[(startFreq ^ freq_mask)*fStep], n_freqs_per_thread*number_products*sizeof(float));

			size_t xx_index  = 0;
			size_t yy_index  = 1;

			for (int cur_int=0; cur_int<l; cur_int++){
				for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq+=2){ // two at a time
					size_t in_index  = (((cur_int * intStep) + cur_freq)>>1); // v4s index
					size_t f_index_1 = ((cur_freq + 0) ^ freq_mask)*fStep;   // float index
					size_t f_index_2 = ((cur_freq + 1) ^ freq_mask)*fStep;   // float index


					x[in_index] = __builtin_ia32_mulps( x[in_index], x[in_index]);
					y[in_index] = __builtin_ia32_mulps( y[in_index], y[in_index]);
					__v4sf temp = __builtin_ia32_haddps(x[in_index], y[in_index]);
					a_str[f_index_1 + xx_index]   += ((float*)&temp)[0];
					a_str[f_index_2 + xx_index]   += ((float*)&temp)[1];
					a_str[f_index_1 + yy_index]   += ((float*)&temp)[2];
					a_str[f_index_2 + yy_index]   += ((float*)&temp)[3];

					// xx
					//a_str[f_index_1 + xx_index] += ((float*)&x[in_index])[0] + ((float*)&x[in_index])[1];
					//a_str[f_index_2 + xx_index] += ((float*)&x[in_index])[2] + ((float*)&x[in_index])[3];


					// yy
					//a_str[f_index_1 + yy_index] += ((float*)&y[in_index])[0] + ((float*)&y[in_index])[1];
					//a_str[f_index_2 + yy_index] += ((float*)&y[in_index])[2] + ((float*)&y[in_index])[3];

				} // loop on frequency
			} // loop on integration count
		} // loop on stream

	}
	void doAcc_XXXYYXYY( unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_I(        unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_Q(        unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_U(        unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_V(        unsigned bIdx,unsigned threadIndex){ UNSUPPORTED_MODE(); }
	void doAcc_IV(       unsigned bIdx,unsigned threadIndex){
		// each thread computes all output products for
		//      * (Nfreqs/Nthreads) frequencies,
		//           for all streams,
		//               integrating from 0 to Nints


		// input stepping
		unsigned n_freqs_per_thread = k/number_threads;                  // units of complex
		unsigned startFreq          = threadIndex * n_freqs_per_thread;  // units of complex
		unsigned stopFreq           = startFreq + n_freqs_per_thread;
		unsigned intStep            = k;                                 // units of complex
		// output stepping
		unsigned fStep              = number_products;


		for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
			// where is x starting from?
			unsigned cIdx_x       = cellIndex(bIdx, cur_str, POL_X); //assert(cIdx_x < total_cells);
			fftwf_complex* x_base = getCellOdata(cIdx_x);
			__v4sf* x             = (__v4sf*) x_base;

			// where is y starting from?
			unsigned cIdx_y       = cellIndex(bIdx, cur_str, POL_Y); //assert(cIdx_y < total_cells);
			fftwf_complex* y_base = getCellOdata(cIdx_y);
			__v4sf* y             = (__v4sf*) y_base;

			// where does data for the block go?
			float* a_base = adata[bIdx];
			float* a_str  = &a_base[k*number_products*cur_str];

			unsigned freq_mask = k>>1;

			// pre-zero the accumulator
			bzero((void*) &a_str[(startFreq ^ freq_mask)*fStep], n_freqs_per_thread*number_products*sizeof(float));

			for (int cur_int=0; cur_int<l; cur_int++){
				for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq+=4){ // 4 at a time
					size_t in_index1  = (((cur_int * intStep) + cur_freq)>>1); // v4s index
					size_t in_index2  = in_index1 + 1;
					size_t f_index_1 = ((cur_freq + 0) ^ freq_mask)*fStep;   // float index
					size_t f_index_2 = ((cur_freq + 1) ^ freq_mask)*fStep;   // float index
					size_t f_index_3 = ((cur_freq + 2) ^ freq_mask)*fStep;
					size_t f_index_4 = ((cur_freq + 3) ^ freq_mask)*fStep;

					size_t i_index  = 0;
					size_t v_index  = 1;

					// first compute |X| and |Y| so we can use the space for in place computation
					__v4sf tmpx1 = __builtin_ia32_mulps( x[in_index1], x[in_index1]); // square               [    x0r,     x0i,     x1r,     x1i]
					__v4sf tmpx2 = __builtin_ia32_mulps( x[in_index2], x[in_index2]); // square               [    x2r,     x2i,     x3r,     x3i]
					__v4sf tmpx3 = __builtin_ia32_haddps(tmpx1, tmpx2);               // add squared comps:   [ |X0|^2,  |X1|^2,  |X2|^2,  |X3|^2]
					__v4sf tmpy1 = __builtin_ia32_mulps( y[in_index1], y[in_index1]); // square               [    y0r,     y0i,     y1r,     y1i]
					__v4sf tmpy2 = __builtin_ia32_mulps( y[in_index2], y[in_index2]); // square               [    y2r,     y2i,     y3r,     y3i]
					__v4sf tmpy3 = __builtin_ia32_haddps(tmpy1, tmpy2);               // add squared comps:   [ |y0|^2,  |X1|^2,  |X2|^2,  |X3|^2]
					__v4sf _i    = __builtin_ia32_addps(tmpx3,tmpy3);                 // SUM                  [     I0,      I1,      I2,      I3]
					       tmpx1 = __builtin_ia32_shufps(x[in_index1],x[in_index1],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
					       tmpx2 = __builtin_ia32_shufps(x[in_index2],x[in_index2],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
					__v4sf tmpv1 = __builtin_ia32_mulps( tmpx1, y[in_index1]);        // premult1             [ x0iy0r,  x0ry0i,  x1iy1r,  x1ry1i]
					__v4sf tmpv2 = __builtin_ia32_mulps( tmpx2, y[in_index2]);        // premult2             [ x2iy2r,  x2ry2i,  x3iy3r,  x3ry3i]
					__v4sf _v    = __builtin_ia32_hsubps(tmpv1, tmpv2);               // diff                 [  XY*0i,   XY*1i,   XY*2i,   XY*3i] <note: XY*_n, not XY * n>

					// accumulate bin 1's I and V
					a_str[f_index_1 + i_index] += ((float*)&_i)[0];
					a_str[f_index_1 + v_index] += ((float*)&_v)[0];

					// accumulate bin 2's I and V
					a_str[f_index_2 + i_index] += ((float*)&_i)[1];
					a_str[f_index_2 + v_index] += ((float*)&_v)[1];

					// accumulate bin 3's I and V
					a_str[f_index_3 + i_index] += ((float*)&_i)[2];
					a_str[f_index_3 + v_index] += ((float*)&_v)[2];

					// accumulate bin 4's I and V
					a_str[f_index_4 + i_index] += ((float*)&_i)[3];
					a_str[f_index_4 + v_index] += ((float*)&_v)[3];
				} // loop on frequency
			} // loop on integration count
			// now we need to fix up U's and V's (multiply by 2)
			for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq++){ // 1 at a time here
				size_t f_index = (cur_freq ^ freq_mask)*fStep;
				size_t v_index = 1;
				a_str[f_index + v_index] *= 2;
			}
		} // loop on stream

	}
	void doAcc_IQUV(     unsigned bIdx,unsigned threadIndex){
		// each thread computes all output products for
		//      * (Nfreqs/Nthreads) frequencies,
		//           for all streams,
		//               integrating from 0 to Nints


		// input stepping
		unsigned n_freqs_per_thread = k/number_threads;                  // units of complex
		unsigned startFreq          = threadIndex * n_freqs_per_thread;  // units of complex
		unsigned stopFreq           = startFreq + n_freqs_per_thread;
		unsigned intStep            = k;                                 // units of complex
		// output stepping
		unsigned fStep              = number_products;

		assert(number_products == 4);

		for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
			// where is x starting from?
			unsigned cIdx_x       = cellIndex(bIdx, cur_str, POL_X); //assert(cIdx_x < total_cells);
			fftwf_complex* x_base = getCellOdata(cIdx_x);
			__v4sf* x             = (__v4sf*) x_base;

			// where is y starting from?
			unsigned cIdx_y       = cellIndex(bIdx, cur_str, POL_Y); //assert(cIdx_y < total_cells);
			fftwf_complex* y_base = getCellOdata(cIdx_y);
			__v4sf* y             = (__v4sf*) y_base;

			// where does data for the block go?
			float* a_base = adata[bIdx];
			float* a_str  = &a_base[k*number_products*cur_str];

			unsigned freq_mask = k>>1;

			// pre-zero the accumulator
			bzero((void*) &a_str[(startFreq ^ freq_mask)*fStep], n_freqs_per_thread*number_products*sizeof(float));
#ifdef DEBUG_STOKES_IQUV
			LOG_START_SESSION(L_DEBUG);
			cout << "-----------------------------------------" << endl;
			cout << "k                  " << k                  << endl;
			cout << "l                  " << l                  << endl;
			cout << "number_threads     " << number_threads     << endl;
			cout << "number_products    " << number_products    << endl;
			cout << "bIdx               " << bIdx               << endl;
			cout << "threadIndex        " << threadIndex        << endl;
			cout << "n_freqs_per_thread " << n_freqs_per_thread << endl;
			cout << "startFreq          " << startFreq          << endl;
			cout << "stopFreq           " << stopFreq           << endl;
			cout << "intStep            " << intStep            << endl;
			cout << "fStep              " << fStep              << endl;
			cout << "freq_mask          " << freq_mask          << endl;

			cout << "cur_str        " << cur_str               << endl;
			cout << "number_streams " << number_streams        << endl;
			cout << "cIdx_x         " << cIdx_x                << endl;
			cout << "cIdx_y         " << cIdx_y                << endl;
			cout << "x_base         0x" << hex<<(size_t)x_base   << dec << endl;
			cout << "y_base         0x" << hex<<(size_t)y_base   << dec << endl;
			cout << "x              0x" << hex<<(size_t)x        << dec << endl;
			cout << "y              0x" << hex<<(size_t)y        << dec << endl;
			cout << "a_base         0x" << hex<<(size_t)a_base   << dec << endl;
			cout << "a_str          0x" << hex<<(size_t)a_str    << dec << endl;
			cout << "" << endl;
			LOG_END_SESSION();
#endif
			for (int cur_int=0; cur_int<l; cur_int++){

				for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq+=4){ // 4 at a time
					size_t in_index1  = (((cur_int * intStep) + cur_freq)>>1); // v4s index
					size_t in_index2  = in_index1 + 1;
					size_t f_index_1 = ((cur_freq + 0) ^ freq_mask)*fStep;   // float index
					size_t f_index_2 = ((cur_freq + 1) ^ freq_mask)*fStep;   // float index
					size_t f_index_3 = ((cur_freq + 2) ^ freq_mask)*fStep;
					size_t f_index_4 = ((cur_freq + 3) ^ freq_mask)*fStep;

					size_t i_index  = 0;
					size_t q_index  = 1;
					size_t u_index  = 2;
					size_t v_index  = 3;

					// first compute |X| and |Y| so we can use the space for in place computation
					__v4sf tmpx1 = __builtin_ia32_mulps( x[in_index1], x[in_index1]); // square               [    x0r,     x0i,     x1r,     x1i]
					ASSERT_BUILTIN_MULPS(x[in_index1],x[in_index1],tmpx1);

					__v4sf tmpx2 = __builtin_ia32_mulps( x[in_index2], x[in_index2]); // square               [    x2r,     x2i,     x3r,     x3i]
					ASSERT_BUILTIN_MULPS(x[in_index2],x[in_index2],tmpx2);

					__v4sf tmpx3 = __builtin_ia32_haddps(tmpx1, tmpx2);               // add squared comps:   [ |X0|^2,  |X1|^2,  |X2|^2,  |X3|^2]
					ASSERT_BUILTIN_HADDPS(tmpx1, tmpx2, tmpx3);

					__v4sf tmpy1 = __builtin_ia32_mulps( y[in_index1], y[in_index1]); // square               [    y0r,     y0i,     y1r,     y1i]
					ASSERT_BUILTIN_MULPS(y[in_index1],y[in_index1],tmpy1);

					__v4sf tmpy2 = __builtin_ia32_mulps( y[in_index2], y[in_index2]); // square               [    y2r,     y2i,     y3r,     y3i]
					ASSERT_BUILTIN_MULPS(y[in_index2],y[in_index2],tmpy2);

					__v4sf tmpy3 = __builtin_ia32_haddps(tmpy1, tmpy2);               // add squared comps:   [ |y0|^2,  |X1|^2,  |X2|^2,  |X3|^2]
					ASSERT_BUILTIN_HADDPS(tmpy1, tmpy2, tmpy3);

					__v4sf _i    = __builtin_ia32_addps(tmpx3,tmpy3);                 // SUM                  [     I0,      I1,      I2,      I3]
					ASSERT_BUILTIN_ADDPS(tmpx3,tmpy3,_i);

					__v4sf _q    = __builtin_ia32_subps(tmpx3,tmpy3);                 // DIFF                 [     Q0,      Q1,      Q2,      Q3]
					ASSERT_BUILTIN_SUBPS(tmpx3,tmpy3,_q);

					__v4sf tmpu1 = __builtin_ia32_mulps( x[in_index1], y[in_index1]); // premult1             [ x0ry0r,  x0iy0i,  x1ry1r,  x1iy1i]
					ASSERT_BUILTIN_MULPS(x[in_index1],y[in_index1],tmpu1);

					__v4sf tmpu2 = __builtin_ia32_mulps( x[in_index2], y[in_index2]); // premult2             [ x2ry2r,  x2iy2i,  x3ry3r,  x3iy3i]
					ASSERT_BUILTIN_MULPS(x[in_index2],y[in_index2],tmpu2);

					__v4sf _u    = __builtin_ia32_haddps(tmpu1, tmpu2);               // sum                  [  XY*0r,   XY*1r,   XY*2r,   XY*3r] <note: XY*_n, not XY * n>
					ASSERT_BUILTIN_HADDPS(tmpu1,tmpu2,_u);

						   tmpx1 = __builtin_ia32_shufps(x[in_index1],x[in_index1],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
						   ASSERT_SHUFFLE(x[in_index1],x[in_index1],tmpx1,2,3,0,1);

						   tmpx2 = __builtin_ia32_shufps(x[in_index2],x[in_index2],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
						   ASSERT_SHUFFLE(x[in_index2],x[in_index2],tmpx2,2,3,0,1);

					__v4sf tmpv1 = __builtin_ia32_mulps( tmpx1, y[in_index1]);        // premult1             [ x0iy0r,  x0ry0i,  x1iy1r,  x1ry1i]
					ASSERT_BUILTIN_MULPS(tmpx1, y[in_index1],tmpv1);

					__v4sf tmpv2 = __builtin_ia32_mulps( tmpx2, y[in_index2]);        // premult2             [ x2iy2r,  x2ry2i,  x3iy3r,  x3ry3i]
					ASSERT_BUILTIN_MULPS(tmpx2, y[in_index2],tmpv2);

					__v4sf _v    = __builtin_ia32_hsubps(tmpv1, tmpv2);               // diff                 [  XY*0i,   XY*1i,   XY*2i,   XY*3i] <note: XY*_n, not XY * n>
					ASSERT_BUILTIN_HSUBPS(tmpv1, tmpv2, _v);

					#ifdef DEBUG_STOKES_IQUV
					if (cur_int == 0){
						assert(a_str[f_index_1 + i_index] == 0.0);
						assert(a_str[f_index_1 + q_index] == 0.0);
						assert(a_str[f_index_1 + u_index] == 0.0);
						assert(a_str[f_index_1 + v_index] == 0.0);
						assert(a_str[f_index_2 + i_index] == 0.0);
						assert(a_str[f_index_2 + q_index] == 0.0);
						assert(a_str[f_index_2 + u_index] == 0.0);
						assert(a_str[f_index_2 + v_index] == 0.0);
						assert(a_str[f_index_3 + i_index] == 0.0);
						assert(a_str[f_index_3 + q_index] == 0.0);
						assert(a_str[f_index_3 + u_index] == 0.0);
						assert(a_str[f_index_3 + v_index] == 0.0);
						assert(a_str[f_index_4 + i_index] == 0.0);
						assert(a_str[f_index_4 + q_index] == 0.0);
						assert(a_str[f_index_4 + u_index] == 0.0);
						assert(a_str[f_index_4 + v_index] == 0.0);
					}
					#endif

					// accumulate bin 1's I, Q, U, and V
					a_str[f_index_1 + i_index] += ((float*)&_i)[0];
					a_str[f_index_1 + q_index] += ((float*)&_q)[0];
					a_str[f_index_1 + u_index] += ((float*)&_u)[0];
					a_str[f_index_1 + v_index] += ((float*)&_v)[0];

					// accumulate bin 2's I, Q, U, and V
					a_str[f_index_2 + i_index] += ((float*)&_i)[1];
					a_str[f_index_2 + q_index] += ((float*)&_q)[1];
					a_str[f_index_2 + u_index] += ((float*)&_u)[1];
					a_str[f_index_2 + v_index] += ((float*)&_v)[1];

					// accumulate bin 3's I, Q, U, and V
					a_str[f_index_3 + i_index] += ((float*)&_i)[2];
					a_str[f_index_3 + q_index] += ((float*)&_q)[2];
					a_str[f_index_3 + u_index] += ((float*)&_u)[2];
					a_str[f_index_3 + v_index] += ((float*)&_v)[2];

					// accumulate bin 4's I, Q, U, and V
					a_str[f_index_4 + i_index] += ((float*)&_i)[3];
					a_str[f_index_4 + q_index] += ((float*)&_q)[3];
					a_str[f_index_4 + u_index] += ((float*)&_u)[3];
					a_str[f_index_4 + v_index] += ((float*)&_v)[3];
				} // loop on frequency
			} // loop on integration count
			// now we need to fix up U's and V's (multiply by 2)
			for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq++){ // 1 at a time here
				size_t f_index = (cur_freq ^ freq_mask)*fStep;
				size_t u_index  = 2;
				size_t v_index  = 3;
				a_str[f_index + u_index] *= 2;
				a_str[f_index + v_index] *= 2;
			}
		} // loop on stream

	}


	void doAcc_c_XY(     unsigned bIdx,unsigned threadIndex){

			// input stepping
			unsigned n_samps_per_thread = k/number_threads;                  // units of complex
			unsigned startSamp          = threadIndex * n_samps_per_thread;  // units of complex
			unsigned stopSamp           = startSamp + n_samps_per_thread;
			unsigned sampStep           = l;                                 // units of complex

			// output stepping
			unsigned pStep              = number_products;

			assert(number_products == 1);

			for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
				// where is x starting from?
				unsigned cIdx_x       = cellIndex(bIdx, cur_str, POL_X); //assert(cIdx_x < total_cells);
				fftwf_complex* x_base = getCellOdata(cIdx_x);
				__v4sf* x             = (__v4sf*) x_base;

				// where is y starting from?
				unsigned cIdx_y       = cellIndex(bIdx, cur_str, POL_Y); //assert(cIdx_y < total_cells);
				fftwf_complex* y_base = getCellOdata(cIdx_y);
				__v4sf* y             = (__v4sf*) y_base;

				// where does data for the block go?
				fftwf_complex* a_base = (fftwf_complex*) adata[bIdx];
				fftwf_complex* a_str  = &a_base[k*number_products*cur_str]; // complex data

				__v4sf zero; bzero((void*)&zero, sizeof(__v4sf));

				// pre-zero the accumulator
				bzero((void*) &a_str[startSamp*pStep], n_samps_per_thread*pStep*sizeof(fftwf_complex));

				for (unsigned cur_samp = startSamp; cur_samp<stopSamp; cur_samp++){
					for (int cur_int=0; cur_int<l; cur_int+=4){ // 4 at a time
						size_t in_index1  = (((cur_samp * sampStep) + cur_int)>>1); // v4s index
						size_t in_index2  = in_index1 + 1;

						size_t out_index  = ((cur_samp * pStep)); // complex index

						//size_t xx_index  = 0;
						size_t xy_index  = 0;
						//size_t yx_index  = 2;
						//size_t yy_index  = 3;

						__v4sf tmpxy_r_1  = __builtin_ia32_mulps( x[in_index1], y[in_index1]); // premult1             [ x0ry0r,  x0iy0i,  x1ry1r,  x1iy1i]
						__v4sf tmpxy_r_2  = __builtin_ia32_mulps( x[in_index2], y[in_index2]); // premult2             [ x2ry2r,  x2iy2i,  x3ry3r,  x3iy3i]
						__v4sf tmpxy_r    = __builtin_ia32_haddps(tmpxy_r_1, tmpxy_r_2);       // sum                  [  XY*0r,   XY*1r,   XY*2r,   XY*3r] <note: XY*_n, not XY * n>

						__v4sf tmpxy_i_1  = __builtin_ia32_shufps(x[in_index1],x[in_index1],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
						__v4sf tmpxy_i_2  = __builtin_ia32_shufps(x[in_index2],x[in_index2],_MM_SHUFFLE(2,3,0,1)); // swap real/imag (do this on x so that we can use hsub and the sign will work out)
						__v4sf tmpxy_i_3  = __builtin_ia32_mulps( tmpxy_i_1, y[in_index1]);    // premult1             [ x0iy0r,  x0ry0i,  x1iy1r,  x1ry1i]
						__v4sf tmpxy_i_4  = __builtin_ia32_mulps( tmpxy_i_2, y[in_index2]);    // premult2             [ x2iy2r,  x2ry2i,  x3iy3r,  x3ry3i]
						__v4sf tmpxy_i    = __builtin_ia32_hsubps(tmpxy_i_3, tmpxy_i_4);       // diff                 [  XY*0i,   XY*1i,   XY*2i,   XY*3i] <note: XY*_n, not XY * n>
						__v4sf tmpxy_x2   = __builtin_ia32_haddps(tmpxy_r,tmpxy_i);            // add first two        [ XY*01r,  XY*23r, XY*01i,   XY*23i]
						__v4sf tmpxy_x4   = __builtin_ia32_haddps(tmpxy_x2,zero);              // add first two        [ XY*0123r,  XY*0123i, 0,   0]

						// accumulate real and imaginary parts
						a_str[out_index + xy_index][0] += ((float*)&tmpxy_x4)[0];
						a_str[out_index + xy_index][1] += ((float*)&tmpxy_x4)[1];
						//a_str[out_index + xy_index][0] = (out_index + xy_index);
						//a_str[out_index + xy_index][1] = -(out_index + xy_index);


					} // loop on integration count
				} // loop on sample number of frame
				// now we need to fix up magnitude to normalize by integration count

				for (unsigned cur_samp = startSamp; cur_samp<stopSamp; cur_samp++){
					size_t out_index   = ((cur_samp * pStep)); // complex index
					size_t xy_index    = 0;
					a_str[out_index + xy_index][0] /= l;
					a_str[out_index + xy_index][1] /= l;
				}

			} // loop on stream

		}





	float* getAccAdata(unsigned bIdx){
		return &adata[bIdx][0];
	}


	fftwf_complex* getCellIdata(unsigned cIdx){
		assert(cIdx < total_cells);
		size_t c_data_index = cIdx * samples_per_cell;
		return &idata[c_data_index];
	}

	fftwf_complex* getCellOdata(unsigned cIdx){
		assert(cIdx < total_cells);
		size_t c_data_index = cIdx * samples_per_cell;
		return &odata[c_data_index];
	}


	size_t* getCellFills(unsigned cIdx){
		assert(cIdx < total_cells);
		return &fills[cIdx];
	}

	size_t* getCellSatCounts(unsigned cIdx){
		assert(cIdx < total_cells);
		return &sat_counts[cIdx];
	}


	//clear input data area, fills, sat_counts, and optionally output data for the cell
	void clearCellInput(unsigned cIdx){
		assert(cIdx < total_cells);		size_t c_data_index = cIdx * samples_per_cell;
		bzero((void*)&(idata[c_data_index]), samples_per_cell * sizeof(fftwf_complex));
	}
	// clear cell's oputput data
	void clearCellOutput(unsigned cIdx){
		assert(cIdx < total_cells);		size_t c_data_index = cIdx * samples_per_cell;
		bzero((void*)&(odata[c_data_index]), samples_per_cell * sizeof(fftwf_complex));
	}
	void clearCellCounters(unsigned cIdx){
		assert(cIdx < total_cells);		fills[cIdx]         = 0;
		sat_counts[cIdx]    = 0;
	}

	// compute cell linear index
	inline size_t cellIndex(unsigned bIdx, unsigned sIdx, unsigned pIdx){
		assert(bIdx < number_blocks);
		assert(sIdx < number_streams);
		assert(pIdx < number_cells);
		return
			(bIdx * number_streams * number_cells) +
			(sIdx * number_cells) +
			(pIdx);
	}



	inline bool isValid() const {return valid;}
	string getReason() const {return reason;}






private:
	bool   valid;
	bool   XY_interlaced;     // true for TBW, false otherwise; affects insertion
	ProductType outputType;   // output type XX, YY, IQUV, etc.
	int k;                    // fft length or correlator #samples/frame
	int l;                    // integration count
	size_t number_products;   // 1 to 4
	size_t number_cells;      // 1 or 2
	size_t number_streams;    // 2 for DRX, 260 otherwise
	size_t number_blocks;     // depth of FFT Buffer

	size_t number_threads;// number of fft threads per block

	size_t total_cells;       // total number of individual cells in the buffer
	size_t total_products;    // total number of products in the buffer

	// Cell/stream/block geometry
	size_t samples_per_cell;
	size_t samples_per_stream;
	size_t samples_per_block;
	size_t samples_per_buf;

	// accumulator geometry

	size_t osamples_per_product;
	size_t osamples_per_stream;
	size_t osamples_per_block;
	size_t osamples_per_buf;


	fftwf_plan*       plans;
	fftwf_complex*    idata;
	fftwf_complex*    odata;
	float**           adata;
	size_t*           fills;      // in samples, per cell
	size_t*           sat_counts; // in samples, per cell
	BlockInfo*        bInfo;
	ThreadInfo*       tInfo;     // per-block vector threads to compute FFTs
	string            reason;

	pthread_attr_t    attr;
	DECLARE_ACCESS_MUTEX();

};

#endif /* SPECTROMETER_H_ */





/*
 *
 * generic template for computing stokes
		// each thread computes all output products for
		//      * (Nfreqs/Nthreads) frequencies,
		//           for all streams,
		//               integrating from 0 to Nints


		// input stepping
		unsigned n_freqs_per_thread = k/number_threads;                  // units of complex
		unsigned startFreq          = threadIndex * n_freqs_per_thread;  // units of complex
		unsigned stopFreq           = startFreq + n_freqs_per_thread;
		unsigned intStep            = k;                                 // units of complex
		// output stepping
		unsigned fStep              = number_products;


		// prior to integrating, compute temporaries two-at-a-time with vector ops
		__v4sf tmp_x_conj;
		__v4sf tmp_y_conj;
		__v4sf tmp_xx;
		__v4sf tmp_xy;
		__v4sf tmp_yx;
		__v4sf tmp_yy;
		__v4sf tmp_iq_pre;
		__v4sf tmp_iq;

		for (unsigned cur_str=0; cur_str<number_streams; cur_str++){
			// where is x starting from?
			unsigned cIdx_x       = cellIndex(bIdx, cur_str, POL_X); //assert(cIdx_x < total_cells);
			fftwf_complex* x_base = getCellOdata(cIdx_x);
			__v4sf* x             = (__v4sf*) &x_base[startFreq];

			// where is y starting from?
			unsigned cIdx_y       = cellIndex(bIdx, cur_str, POL_Y); //assert(cIdx_y < total_cells);
			fftwf_complex* y_base = getCellOdata(cIdx_y);
			__v4sf* y             = (__v4sf*) &y_base[startFreq];

			// where does data for the block go?
			float* a_base = adata[bIdx];
			float* a_str  = &a_base[k*number_products*cur_str];

			unsigned freq_mask = k>>2;
			for (int cur_int=0; cur_int<l; cur_int++){
				for (unsigned cur_freq = startFreq; cur_freq<stopFreq; cur_freq+=2){ // two at a time
					size_t in_index = (((cur_int * intStep) + cur_freq)>>1);
					size_t f_index_1 = ((cur_freq + 0) ^ freq_mask)*fStep;
					size_t f_index_2 = ((cur_freq + 1) ^ freq_mask)*fStep;

					size_t xx_index  = 0;
					size_t xy_index  = 1;
					size_t yx_index  = 2;
					size_t yy_index  = 3;
					size_t i_index  = 0;
					size_t q_index  = 1;
					size_t u_index  = 2;
					size_t v_index  = 3;

					cplx_conj( &x[in_index], &tmp_x_conj );
					cplx_conj( &y[in_index], &tmp_y_conj );
					cplx_mult( &x[in_index], &tmp_x_conj, &tmp_xx);
					cplx_mult( &x[in_index], &tmp_y_conj, &tmp_xy);
					cplx_mult( &y[in_index], &tmp_x_conj, &tmp_yx);
					cplx_mult( &y[in_index], &tmp_y_conj, &tmp_yy);
					cplx_mag_pre(
							&x[in_index],
							&y[in_index],
							&tmp_iq_pre
					);

					// xx
					a_str[f_index_1 + xx_index] += ((float*)&tmp_xx)[0] + ((float*)&tmp_xx)[1];
					a_str[f_index_2 + xx_index] += ((float*)&tmp_xx)[2] + ((float*)&tmp_xx)[3];

					// xy
					a_str[f_index_1 + xy_index] += ((float*)&tmp_xy)[0] + ((float*)&tmp_xy)[1];
					a_str[f_index_2 + xy_index] += ((float*)&tmp_xy)[2] + ((float*)&tmp_xy)[3];

					// yx
					a_str[f_index_1 + yx_index] += ((float*)&tmp_yx)[0] + ((float*)&tmp_yx)[1];
					a_str[f_index_2 + yx_index] += ((float*)&tmp_yx)[2] + ((float*)&tmp_yx)[3];

					// yy
					a_str[f_index_1 + yy_index] += ((float*)&tmp_yy)[0] + ((float*)&tmp_yy)[1];
					a_str[f_index_2 + yy_index] += ((float*)&tmp_yy)[2] + ((float*)&tmp_yy)[3];


					// i
					cplx_mag_sum(
						 &tmp_iq_pre,
						 &((float*)&tmp_iq)[0],
						 &((float*)&tmp_iq)[1]
					);
					a_str[f_index_1 + i_index] += ((float*)&tmp_iq)[0];
					a_str[f_index_2 + i_index] += ((float*)&tmp_iq)[1];

					//q
					cplx_mag_dif(
						 &tmp_iq_pre,
						 &((float*)&tmp_iq)[2],
						 &((float*)&tmp_iq)[3]
					);
					a_str[f_index_1 + q_index] += ((float*)&tmp_iq)[2];
					a_str[f_index_2 + q_index] += ((float*)&tmp_iq)[3];

					//u
					a_str[f_index_1 + u_index] += 2* (((float*)&tmp_xy)[0]);
					a_str[f_index_2 + u_index] += 2* (((float*)&tmp_xy)[2]);

					//v
					a_str[f_index_1 + v_index] += 2* (((float*)&tmp_xy)[1]);
					a_str[f_index_2 + v_index] += 2* (((float*)&tmp_xy)[3]);

				} // loop on frequency
			} // loop on integration count
		} // loop on stream
*/
