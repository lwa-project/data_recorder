// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#ifndef IPSPEC_H_
#define IPSPEC_H_

#include "../Primitives/StdTypes.h"

#include <unistd.h>
#include <netdb.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include "../Primitives/TypeConversion.h"
#include "../Primitives/StringList.h"
#include "../Common/Utility.h"


class IpSpec {
public:
	friend ostream& operator << (ostream& out, const IpSpec& m);
	static const string re_octet;
	static const string re_bioctet;
	static const string re_port_no;
	static const string re_dot;
	static const string re_colon;
	static const string re_dotted_quad;
	static const string re_ipv6_p;
	static const string re_ipv4;
	static const string re_ipv6;
	static const string re_ip;

	IpSpec(const unsigned short& port=0, const string& ip="127.0.0.1", const bool& v4=true):
		_isip(true),_isip4(v4),	_isip6(!v4),_hasport(true),_hasip(true),_port(port),_ip(ip)
	{}

	IpSpec& operator=(const string& rep){
		assign(rep);
		return *this;
	}
	IpSpec(const string& rep):
		_isip(false),_isip4(false),	_isip6(false),_hasport(false),_hasip(false),_port(0),_ip("127.0.0.1")
	{
		assign(rep);
	}

	IpSpec(const struct sockaddr_storage& sa):
		_isip(false),_isip4(false),	_isip6(false),_hasport(false),_hasip(false),_port(0),_ip("127.0.0.1")
	{
		char buf[8192];
		switch(sa.ss_family) {
			case AF_INET:
				inet_ntop(AF_INET, &(((const struct sockaddr_in *)&sa)->sin_addr), buf, 8192 );
				_ip   = string(buf);
				_port = ((struct sockaddr_in *)&sa)->sin_port;
				_isip = _isip4 = _hasport = _hasip = true;
				break;
			case AF_INET6:
				inet_ntop(AF_INET6, &(((const struct sockaddr_in6 *)&sa)->sin6_addr), buf, 8192 );
				_ip   = string(buf);
				_port = ((struct sockaddr_in6 *)&sa)->sin6_port;
				_isip = _isip6 = _hasport = _hasip = true;
				break;
			default:
				_ip   = "Unknown Address Family";
				break;
		}
	}

	void pack(struct sockaddr_storage& sa){
		bzero((void*)&sa, sizeof(struct sockaddr_storage));
		sa.ss_family = AF_UNSPEC;
		if (_isip && _hasip && _hasport && (_isip6 || _isip4)){
			if (_isip6){
				// v6
				sa.ss_family = AF_INET6;
				inet_pton(AF_INET6, _ip.c_str(), &(((struct sockaddr_in6 *)&sa)->sin6_addr));
				((struct sockaddr_in6 *)&sa)->sin6_port = htons((unsigned short)_port);
			} else {
				// v4
				sa.ss_family = AF_INET;
				inet_pton(AF_INET,  _ip.c_str(), &(((struct sockaddr_in *)&sa)->sin_addr));
				((struct sockaddr_in *)&sa)->sin_port = htons((unsigned short)_port);
			}
		}
	}

	string toString() const {
		if (_isip){
			if (_hasip){
				if (_hasport){
					if (_isip6){
						return  "["+_ip+"]:"+LXS(_port);
					} else {
						return  _ip + ":" + LXS(_port);
					}
				} else {
					return  _ip;
				}
			}else{
				if (_hasport){
					return ":" + LXS(_port);
				} else {
					return "Illegal Address";
				}
			}
		} else {
			return "Illegal Address";
		}
	}
	bool           isIp()    const {return _isip;}
	bool           isIpv4()  const {return _isip4;}
	bool           isIpv6()  const {return _isip6;}
	bool           hasIp()   const {return _hasip;}
	bool           hasPort() const {return _hasport;}
	string         getIp()   const {return _ip; }
	unsigned short getPort() const {return _port;}
	void           changePort(unsigned short p){
		_port = p;
		_hasport = true;
	}
	void           changeIp(const string& ip){
		StringList matches = Utility::getMatches(re_ip,ip,true);
		size_t sz = matches.size();
		if (!sz) return;
		bool __isip    = sz>=1;
		bool __hasip   = (sz>=2) && (!matches[1].empty());
		bool __hasport = (sz>=3) && (!matches[2].empty());
		if (__isip){
			_isip=true;
			if (__hasip){
				_hasip=true;
				_ip = matches[1];
				if(_ip.find(':')!=string::npos){
					_isip6=true;
				} else {
					_isip4=true;
				}
			}
			if (__hasport){
				_port    =  strtoul(matches[2].c_str(),NULL,10);
				_hasport = true;
			}
		}
	}

	virtual ~IpSpec(){}

	static string addrFamilyToStr(unsigned short sa_family){
		#define cxrx(x) case x: return #x
		switch (sa_family){
			cxrx(AF_ALG);    cxrx(AF_APPLETALK); cxrx(AF_ASH);        cxrx(AF_ATMPVC);   cxrx(AF_ATMSVC);
			cxrx(AF_AX25);   cxrx(AF_BLUETOOTH); cxrx(AF_BRIDGE);     cxrx(AF_CAIF);     cxrx(AF_CAN);
			cxrx(AF_DECnet); cxrx(AF_ECONET);    cxrx(AF_IEEE802154); cxrx(AF_INET);     cxrx(AF_INET6);
			cxrx(AF_IPX);    cxrx(AF_IRDA);      cxrx(AF_ISDN);       cxrx(AF_IUCV);     cxrx(AF_KEY);
			cxrx(AF_LLC);    cxrx(AF_LOCAL);     cxrx(AF_MAX);        cxrx(AF_NETBEUI);  cxrx(AF_NETLINK);
			cxrx(AF_NETROM); cxrx(AF_NFC);       cxrx(AF_PACKET);     cxrx(AF_PHONET);   cxrx(AF_PPPOX);
			cxrx(AF_RDS);    cxrx(AF_ROSE);      cxrx(AF_RXRPC);      cxrx(AF_SECURITY); cxrx(AF_SNA);
			cxrx(AF_TIPC);   cxrx(AF_UNSPEC);    cxrx(AF_WANPIPE);    cxrx(AF_X25);
			//cxrx(AF_FILE); //cxrx(AF_ROUTE);   //cxrx(AF_UNIX);
		default: return "Unknown Address Family";
		}
	}


private:
	bool _isip;
	bool _isip4;
	bool _isip6;
	bool _hasport;
	bool _hasip;
	size_t _port;
	string _ip;
	void assign(const string& rep){
		StringList matches = Utility::getMatches(re_ip,rep,true);
		size_t sz = matches.size();
		if (!sz) return;
		_isip    = sz>=1;
		_hasip   = (sz>=2) && (!matches[1].empty());
		_hasport = (sz>=3) && (!matches[2].empty());
		if (_isip){
			if (_hasip){
				_ip = matches[1];
				if(_ip.find(':')!=string::npos){
					_isip6=true;
				} else {
					_isip4=true;
				}
			}
			if (_hasport){
				_port=strtoul(matches[2].c_str(),NULL,10);
			}
		}

	}
};
ostream& operator << (ostream& out, const IpSpec& m);

#endif /* IPSPEC_H_ */
