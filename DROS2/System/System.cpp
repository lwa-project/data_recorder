// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <csignal>
#include "../Derived/DrosVersion.h"
#include "System.h"
#include "Config.h"
#include "Storage.h"
#include "File.h"
#include "Folder.h"
#include "CpuInfo.h"
#include "HddInfo.h"
#include "Log.h"
#include "Shell.h"
#include "Time.h"
#include "../Actors/Schedule.h"
#include "../Common/Actors.h"
#include "../Streaming/TicketBuffer.h"
#include "../Actors/Receiver.h"
#include "../Spectrometer/DrxSpectrometer.h"

///////////////////////////////////////////////////////////////////
// static interface
///////////////////////////////////////////////////////////////////
DEFN_ENUM_STR(E_SS, E_SS_VALS);
SINGLETON_CLASS_SOURCE(System);

bool System::initialStorageScanCompleted=false;
bool System::rebootStorageScanFull=false;
bool System::asynchStorageScanFull=false;


void  System::notifyFatalError(string who, string what){
	SERIALIZE_ACCESS_ST();
	LOGC(L_INFO, "[System] Subsystem '"+who+"' reported a fatal error: '"+what+"'", SYSTEM_COLORS);
	System* i = System::get();
	if (i){
		i->_fatal_error = true;
	}
}

bool System::handleException(std::exception* e){
	fprintf(stderr, "[System] Exception occurred '%s'", string(e->what()).c_str());
	fflush(stdout);
	System::get()->notifyFatalError("System","Exception Caught");
	Log::createDump();
	return true;
}
///////////////////////////////////////////////////////////////////
// object interface
///////////////////////////////////////////////////////////////////
SINGLETON_CLASS_CONSTRUCTOR(System):

	rs(NULL),
	mp(NULL),
	ml(NULL),
	sch(NULL),
	defaultDRSU(NULL),
	rx(NULL),
	tx(NULL),
	rxbuf(NULL),
	state(SysUninit),
	_logMessaging(true),
	_shutdownRequested(false),
	_scramRequested(false),
	_restartRequested(false),
	_iniRequested(false),
	_fatal_error(false){
	// do stuff //
}

SINGLETON_CLASS_DESTRUCTOR(System){
	// do stuff //
}


bool System::Run(){// runs until the system needs to be shutdown, ini'd, etc. return val indicates whether it should be run again.
	__boot();
	__run();
	__shutdown();
	return _iniRequested || _restartRequested;
};

void  System::__boot(){
	ThreadManager::getInstance()->reset();
	ThreadManager::getInstance()->announceSelf("System");
	string thread_report = ThreadManager::threadReport();
	LOG_START_SESSION(L_INFO);
		cout << thread_report;
	LOG_END_SESSION();

	state=SysBooting;
	LOGC(L_INFO, "[System] Booting Start", SYSTEM_COLORS);
	LOGC(L_INFO, "[System] Hardware CPU count: "+LXS(boost::thread::hardware_concurrency()), SYSTEM_COLORS);

	LOGC(L_INFO, "[System] Read config...", SYSTEM_COLORS);
	// read config
	if (Config::get() == NULL){
		Config::reanimate();
		Config::get();
	}
	if (Config::get() == NULL){
		LOGC(L_FATAL, "[System] Can't allocate configuration parser", FATAL_COLORS);
		_fatal_error = true; return;
	}


	LOGC(L_INFO, "[System] Scan storage devices...", SYSTEM_COLORS);
	// up storage
	switch(Storage::getState()){
		case Down: {
			Storage::up(!initialStorageScanCompleted || rebootStorageScanFull);
			if (!initialStorageScanCompleted){
				initialStorageScanCompleted = true;
			}
		}break;
		default: break;
	}
	Storage::reportAll();
	bool ignored1; string ignored2;
	getDefaultStorage(ignored1, ignored2);


	LOGC(L_INFO, "[System] Initialize scheduler...", SYSTEM_COLORS);
	// up scheduler
	Schedule* si=Schedule::get();
	if (si == NULL){
		Schedule::reanimate();
		si=Schedule::get();
	}
	if (!si){
		LOGC(L_FATAL, "[System] Can't allocate scheduler", FATAL_COLORS);
		_fatal_error = true; return;
	}
	si->start();
	sch=si;

	LOGC(L_INFO, "[System] Initialize receive buffer...", SYSTEM_COLORS);
	// create input buffer
	rxbuf = new TicketBuffer("MasterReceiveBuffer");
	if (!rxbuf){
		LOGC(L_FATAL, "[System] Can't allocate receive buffer", FATAL_COLORS);
		_fatal_error = true; return;
	}

	// start data pipeline
	// start data transmitter

	LOGC(L_INFO, "[System] Initialize receiver...", SYSTEM_COLORS);
	// start data receiver
	rx=new Receiver(CONF_GET(DataInPort),rxbuf);
	if (!rx){
		LOGC(L_FATAL, "[System] Can't allocate receiver", FATAL_COLORS);
		_fatal_error = true; return;
	}
	LOGC(L_INFO, "[System] Wait for receiver to start...", SYSTEM_COLORS);
	rx->start();
	while (!rx->isStarted() && !rx->isDone()){}
	if (rx->isDone()){
		LOGC(L_FATAL, "[System] Can't start receiver", FATAL_COLORS);
		_fatal_error = true; return;
	}


	LOGC(L_INFO, "[System] Start messaging responder...", SYSTEM_COLORS);
	// start response sender
	rs = new ResponseSender(CONF_GET(MessageOutPort),50);
	if (!rs){
		LOGC(L_FATAL, "[System] Can't allocate response sender", FATAL_COLORS);
		_fatal_error = true; return;
	}
	rs -> start();


	LOGC(L_INFO, "[System] Start message processor...", SYSTEM_COLORS);
	// start message processor
	mp = new MessageProcessor(50);
	if (!mp){
		LOGC(L_FATAL, "[System] Can't allocate message processor", FATAL_COLORS);
		_fatal_error = true; return;
	}
	mp -> start();

	// start message listener

	LOGC(L_INFO, "[System] Start message receiver...", SYSTEM_COLORS);
	ml = new MessageListener(CONF_GET(MessageInPort),50);
	if (!ml){
		LOGC(L_FATAL, "[System] Can't allocate message listener", FATAL_COLORS);
		_fatal_error = true; return;
	}
	ml -> start();



	/* >>> determine system state here <<<*/
	LOGC(L_INFO, "[System] Determining system status...", SYSTEM_COLORS);
	__scanSystemState();
	LOGC(L_INFO, "[System] system is '"+getCurrentStatus()+"'", blink, white, red);
	LOGC(L_INFO, "[System] Booting Complete", SYSTEM_COLORS);



}
/*
void System::spectest(){
	bool   accept;
	string comment;
	LOGC(L_FATAL,"ALLOC", FATAL2_COLORS);
	DrxSpectrometer* d  = new DrxSpectrometer(512,6144,8,XXYY,rxbuf);
	if (!d || !d->isValid()){
		LOGC(L_FATAL,"BAD ALLOC or INVALID", FATAL2_COLORS);
		return;
	}
	LOGC(L_FATAL,"START", FATAL2_COLORS);
	d->start();
	LOGC(L_FATAL,"SLEEP", FATAL2_COLORS);
	usleep(3000000);
	LOGC(L_FATAL,"STOP PRODUCING", FATAL2_COLORS);
	d->stopProducing();
	LOGC(L_FATAL,"STOP RECEIVING", FATAL2_COLORS);
	d->stopReceiving();
	LOGC(L_FATAL,"STOP", FATAL2_COLORS);
	d->stop();
	LOGC(L_FATAL,"DELETE", FATAL2_COLORS);
	delete(d);

}*/
void  System::__run(){
	//spectest();
	bool done = false;
	while (!done){
		usleep(100000);// ~10Hz
		{
			SERIALIZE_ACCESS();
			__scanSystemState();
			done = (_fatal_error || _shutdownRequested || _iniRequested);
		}
	}
}

void  System::__shutdown(){
	state = SysShuttingDown;
	LOGC(L_INFO, "[System] Shutdown Start", SYSTEM_COLORS);

	LOGC(L_INFO, "[System] Shutting down message receiver...", SYSTEM_COLORS);
	// stop message listener
	if (ml){
		ml->doAbort();
		ml->stop();
		delete ml;
		ml=NULL;
	}

	LOGC(L_INFO, "[System] Shutting down message processor...", SYSTEM_COLORS);
	// stop message processor
	if (mp){
		mp->doAbort();
		mp->stop();
		delete mp;
		mp=NULL;
	}

	LOGC(L_INFO, "[System] Shutting down message responder...", SYSTEM_COLORS);
	// stop response sender
	if (rs){
		rs->doAbort();
		rs->stop();
		delete rs;
		rs=NULL;
	}



	// if ini with the -D option supplied, "format" DRSU as we go down
	if (_iniRequested && _iniFlushData){
		LOGC(L_WARNING, "[System] : INI invoked with -D (flush data) option. Now formatting default DRSU!!!", SECURITY_COLORS);
		if (Storage::isUp()){
			if (defaultDRSU){
				if (defaultDRSU->isValid()){
					defaultDRSU->formatDevice();
				}
			}
		}
	}

	/* >>> system state undefined here <<<*/
	// stop data receiver

	LOGC(L_INFO, "[System] Shutting down receiver...", SYSTEM_COLORS);
	rx->doAbort();
	rx->packetBurn();
	rx->stop();

	// stop data transmitter
	// stop data pipeline

	// free the buffer
	LOGC(L_INFO, "[System] Destroying receive buffer...", SYSTEM_COLORS);
	delete rxbuf;

	LOGC(L_INFO, "[System] Shutting down scheduler...", SYSTEM_COLORS);
	// down scheduler
	Schedule* si=Schedule::get();
	if (si != NULL){
		si->doAbort();
		si->stop();
		Schedule::kill();
	}

	LOGC(L_INFO, "[System] Shutting down storage...", SYSTEM_COLORS);
	// down storage
	switch(Storage::getState()){
		case Down: break;
		default:
			Storage::down(!initialStorageScanCompleted || rebootStorageScanFull);
			break;
	}
	Storage::reportAll();


	LOGC(L_INFO, "[System] Shutting down config...", SYSTEM_COLORS);
	// save config
	if (Config::get() != NULL){
		Config::kill();
	}

	state = SysUninit;
	LOGC(L_INFO, "[System] Shutdown Complete", SYSTEM_COLORS);
}

string System::getSubsystemId(){
	SERIALIZE_ACCESS();
	return CONF_GET(MyReferenceDesignator);
}

void System::__scanSystemState(){
	SERIALIZE_ACCESS();
	switch(Storage::getState()){
	case Down:
	case UpExternal:
		state = SysMaintenance;
		break;
	case UpInternal:
	case UpBoth:
		state = SysOperational;
		break;
	}
}
string System::getCurrentStatus(){
	SERIALIZE_ACCESS();
	if (state == SysMaintenance) __scanSystemState();
	switch (state){
	case SysBooting:
		return "BOOTING";
	case SysOperational:
		return "NORMAL ";
	case SysMaintenance:
		return "ERROR  ";
	case SysUninit:       // fall-through
	case SysShuttingDown:
		return "SHUTDWN";
	default:
		return "ERROR  ";
	}
}
string System::getInfo(){
	bool accept=false;
	string comment="";
	Receiver* rx=NULL;
	SERIALIZE_ACCESS();

	if (state == SysMaintenance) __scanSystemState();
	switch (state){
	case SysBooting:
		return "Booting";
	case SysOperational:
		rx = getReceiver(accept,comment);
		if (!rx || !accept){
			return comment;
		}
		return "Operational";
	case SysMaintenance:
		return "Maintenance mode: No internal storage";
	case SysUninit:       // fall-through
	case SysShuttingDown:
		return "Shutdown by command or had fault";
	default:
		return "Program error: reached unreachable state";
	}
}
string System::getVersion(){
	return __DROS_VERSION__;
}
bool   System::en_LogMessaging(){
	SERIALIZE_ACCESS();
	return _logMessaging;
}
void   System::requestShutdown(bool restart, bool scram, bool rescanStorage){
	SERIALIZE_ACCESS();
	rebootStorageScanFull = rescanStorage;
	_restartRequested  = restart;
	_scramRequested    = scram;
	_shutdownRequested = true;

}
void   System::requestIni(bool flushData, bool rescanStorage){
	SERIALIZE_ACCESS();
	_iniRequested      = true;
	_iniFlushData      = flushData;
	rebootStorageScanFull = rescanStorage;
}

bool System::stateCheck(
		Requirements r,
		bool& accept, string& comment){
	SERIALIZE_ACCESS();
	bool needMaintenanceMode  = ((r & RR_STO_DOWN)      != 0);
	bool needInternal         = ((r & RR_STO_INT)       != 0);
	bool needExternal         = ((r & RR_STO_EXT)       != 0);
	bool needEmptySchedule    = ((r & RR_SCH_EMPTY)     != 0);
	bool needNonEmptySchedule = ((r & RR_SCH_NOT_EMPTY) != 0);
	bool needSchedule = needEmptySchedule || needNonEmptySchedule;


	StorageState ss = Storage::getState();
	accept = true;
	switch(ss){
		case Down:
			if (needInternal || needExternal){ accept = false; comment = "Storage unavailable in maintenance mode";}
			break;
		case UpInternal:
			if (needExternal){accept = false; comment = "Storage unavailable (External)";}
			if (needMaintenanceMode){accept = false; comment = "DR not in maintenance mode";}
			break;
		case UpExternal:
			if (needInternal){accept = false; comment = "Storage unavailable (Internal)";}
			if (needMaintenanceMode){accept = false; comment = "DR not in maintenance mode";}
			break;
		default:
			if (needMaintenanceMode){accept = false; comment = "DR not in maintenance mode";}
			break;
	}
	if (sch){
		switch(sch->getState()){
			case SchBusy:
			case SchWait:
				if (needEmptySchedule){accept = false; comment = "Prohibited while operations are scheduled or in progress";}
				break;
			case SchIdle:
			default:
				if (needNonEmptySchedule){accept = false; comment = "No operations scheduled";}
				break;
		}
	} else {
		if (needSchedule){accept = false; comment = "Subsystem not available: 'Scheduler'";}
	}
	return accept;
}

Schedule* System::getSchedule(bool& accept, string& comment){
	SERIALIZE_ACCESS();
	if (sch){
		accept = true; comment = ""; return sch;
	} else {
		accept = false;
		comment = "Subsystem not available: 'Scheduler'";
		return NULL;
	}
}
Receiver* System::getReceiver(bool& accept, string& comment){
	SERIALIZE_ACCESS();
	Receiver* rv = rx;
	if (!rv || !rv->isStarted() || rv->isDone() || rv->isInterrupted()){
		accept = false;
		comment = "Subsystem not available: 'Receiver'";
		return NULL;
	} else {
		accept = true; comment = ""; return rv;
	}
}

void System::requestUp(bool& accept, string& comment){
	SERIALIZE_ACCESS();
	if (!stateCheck(RR_STO_DOWN, accept, comment)) return;
	if (Storage::upAsynch(!initialStorageScanCompleted || rebootStorageScanFull || asynchStorageScanFull)){
		accept=true; comment="System leaving maintenance mode. Please wait 120 seconds";
		if (!initialStorageScanCompleted)
			initialStorageScanCompleted = true;
		if (rebootStorageScanFull)
			rebootStorageScanFull = false;
		if (asynchStorageScanFull)
			asynchStorageScanFull = false;
	} else {
		accept=false; comment="Cannot comply, was not in maintenance mode, or previous request did not complete.";
	}


}
void System::requestDown(bool& accept, string& comment, bool full){
	SERIALIZE_ACCESS();
	if (!stateCheck(RR_STO_UP, accept, comment)) return;
	defaultDRSU = NULL;
	state = SysMaintenance;
	asynchStorageScanFull = full;
	if (Storage::downAsynch(!initialStorageScanCompleted || asynchStorageScanFull)){
		accept=true; comment="System entering maintenance mode. Please wait 120 seconds";
	} else {
		accept=false; comment="Cannot comply, was already in maintenance mode, or previous request did not complete.";
	}
}

void System::setDefaultStorage(string arraySelect, bool& accept, string& comment){
	SERIALIZE_ACCESS();
	if (!stateCheck(RR_STO_INT | RR_SCH_EMPTY, accept, comment)) return;
	if (Storage::isUp()){
		int id = Storage::resolveArraySelect(ST_INTERNAL, arraySelect,comment);
		if (id<0){
			accept=false; return;
		}
		Storage* s = Storage::getDevice(id,ST_INTERNAL);
		if (s==NULL){
			accept = false; comment="Program error: array select resolved to a storage device, but subsequent retrieval failed";
		}
		if (s->getStorageType() != ST_INTERNAL){
			accept=false;
			comment = "Program error: array select resolved to a non-internal storage device.";
			return;
		}
		if (this->defaultDRSU == s){
			accept=false;
			comment="DRSU Number " + LXS(s->getId()+1) + " with volume name '" + s->getVolumeName()+ "' was already selected";
			return;
		}
		this->defaultDRSU = s;
		CONF_SET(ArraySelect,arraySelect);
		accept=true;
		comment="DRSU Number " + LXS(s->getId()+1) + " with volume name '" + s->getVolumeName()+ "' is now the default internal storage device";
	} else {
		accept = false; comment="Cannot select while in maintenance mode.";
	}
}

Storage* System::getDefaultStorage(bool& accept, string& comment){
	SERIALIZE_ACCESS();
	if (!stateCheck(RR_STO_INT, accept, comment)) return NULL;
	if (!Storage::isUp()){
		accept = false; comment="Storage device not available in maintenance mode";
		return NULL;
	} else {
		if (defaultDRSU!=NULL){
			accept=true;
			comment = "";
			return defaultDRSU;
		} else {
			int id = Storage::resolveArraySelect(ST_INTERNAL, CONF_GET(ArraySelect),comment);
			if (id < 0){
				CONF_SET(ArraySelect,"1");
				id = Storage::resolveArraySelect(ST_INTERNAL, CONF_GET(ArraySelect),comment);
				if (id < 0){
					comment="Program error: storage is up but could not resolve default DRSU number";
					accept = false;
					return NULL;
				}
			}
			Storage* s = Storage::getDevice(id,ST_INTERNAL);
			if (s==NULL){
				accept = false; comment="Program error: array select resolved to a storage device, but subsequent retrieval failed";
			}
			defaultDRSU = s;
			return s;
		}
	}
}

Storage* System::getAlternateStorage(StorageType st, const string& arraySelect, bool& accept, string& comment){
	SERIALIZE_ACCESS();
	if ((st==ST_INTERNAL) && (!stateCheck(RR_STO_INT, accept, comment))) return NULL;
	if ((st==ST_EXTERNAL) && (!stateCheck(RR_STO_EXT, accept, comment))) return NULL;
	if (!Storage::isUp()){
		accept = false; comment="Storage device not available in maintenance mode";
		return NULL;
	} else {
		int id = Storage::resolveArraySelect(st, arraySelect,comment);
		if (id < 0)	return NULL;
		Storage* s = Storage::getDevice(id,st);
		if (s==NULL){
			accept = false;
			comment="Program error: array select resolved to a storage device, but subsequent retrieval failed";
			return NULL;
		}
		accept=true; comment="";
		return s;
	}
}


void System::handleSignal(int sig){
	switch(sig) {
	case SIGINT:
		LOGC(L_WARNING, "[System]: received shutdown request via keyboard interrupt", SYSTEM_COLORS);
		_shutdownRequested = true;
		return;
	case SIGUSR1:
		LOGC(L_WARNING, "[System]: received shutdown request via service interface", SYSTEM_COLORS);
		_shutdownRequested = true;
		return;
	case SIGTERM:
		LOGC(L_WARNING, "[System]: received TERM signal", SYSTEM_COLORS);
		_scramRequested = true;
		_shutdownRequested = true;
		return;
	default:
		LOGC(L_WARNING, "[System]: received unknown signal: " + LXS(sig), SYSTEM_COLORS);
		_shutdownRequested = true;
		return;
	}

}
