// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <iostream>
#include <cstdlib>
#include "../Common/misc.h"
#include "../Common/branchPredict.h"
#include "../System/Log.h"
#include "GenericBuffer.h"
#include <boost/thread.hpp>
#include <boost/random.hpp>
using namespace std;
using namespace boost;

GenericBuffer::GenericBuffer(size_t objSize, size_t objCount, size_t numStages):
	valid(false),
	buf(NULL),
	stage_indices(NULL),
	objSize(objSize),	objCount(objCount+1),	numStages(numStages)
	{
	if (
			(objSize <=0 ) ||
			(objCount <=0 ) ||
			(numStages <=0 )
		){
		return;
	}
	LOGC(L_DEBUG, "[GenericBuffer<char["+LXS(objSize)+"]>] Constructed : (" + LXS(objCount) + "," +LXS(numStages) + ")", ACTOR_COLORS);

	buf = malloc (this->objSize*this->objCount);
	if (!buf) {
		LOGC(L_DEBUG, "[GenericBuffer<char["+LXS(objSize)+"]>] Allocation failed", ACTOR_ERROR_COLORS);
		cout << "\n\nGenericBuffer constructor failed.\n\n";
		return;
	}
	stage_indices = (size_t*) malloc((this->numStages+1) * sizeof(size_t));
	if (!stage_indices){
		LOGC(L_DEBUG, "[GenericBuffer<char["+LXS(objSize)+"]>] Allocation failed", ACTOR_ERROR_COLORS);
		free(buf);          buf=NULL;
		return;
	}
	for (size_t i=0; i<=numStages; i++) stage_indices[i] = 0;
	valid=true;
}
void   GenericBuffer::reset(){
	if (unlikely(!valid)) return;
	for (size_t i=0; i<numStages+1; i++) stage_indices[i] = 0;
}

GenericBuffer::~GenericBuffer() {
	if (buf)           free(buf);
	if (stage_indices) free((void*)stage_indices);
}


void*   GenericBuffer::nextIn()const{
	if (unlikely(!valid)) return NULL;
	size_t in    = stage_indices[0];
	size_t out   = stage_indices[numStages];
	size_t avail = RQ_FREE(in,out,objCount);
	if (avail){
		return PTR_TO(buf, objSize, in);
	} else {
		return NULL;
	}
}

void    GenericBuffer::doneIn(void* ptr){
	if (unlikely(!valid)) return;
	size_t in    = stage_indices[0];
	if (unlikely(ptr != PTR_TO(buf, objSize, in))){
		FATAL(USAGE_ERROR,"called doneIn on other than the input object");
	} else {
		stage_indices[0] = (in+1) % objCount;
	}
}

void*   GenericBuffer::nextOut()const{
	if (unlikely(!valid)) return NULL;
	return nextStage(numStages-1);
}

void    GenericBuffer::doneOut(void* ptr){
	if (unlikely(!valid)) return;
	doneStage(numStages-1,ptr);
}

void*   GenericBuffer::nextStage(size_t stage)const{
	if (unlikely(stage>=numStages))	FATAL(USAGE_ERROR,"stage index out of range");
	if (unlikely(!valid)) return NULL;
	size_t s_in    = stage_indices[stage];
	size_t s_out   = stage_indices[stage+1];
	size_t s_used = RQ_USED(s_in,s_out,objCount);
	if (s_used){
		//cout << "[n"<<stage<<"]";cout.flush();
		//cout << "<@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>\n"; cout.flush();
		return PTR_TO(buf, objSize,s_out);
	}
	else {
		//cout << "<.>"; cout.flush();
		return NULL;
	}

}
void*   GenericBuffer::peekStage(size_t stage, size_t peekAhead)const{
	if (unlikely(stage>=numStages))	FATAL(USAGE_ERROR,"stage index out of range");
	if (unlikely(!valid)) return NULL;
	size_t s_in    = stage_indices[stage];
	size_t s_out   = stage_indices[stage+1];
	size_t s_used = RQ_USED(s_in,s_out,objCount);
	if (((size_t)peekAhead) >= s_used)
		return NULL;
	else{
		//cout << "[p"<<stage<<"@"<<peekAhead<<"]";cout.flush();
		return PTR_TO(buf, objSize,((s_out+peekAhead)%objCount));
	}


}

void    GenericBuffer::doneStage(size_t stage, void* ptr){
	if (unlikely(stage>=numStages))	FATAL(USAGE_ERROR,"stage index out of range");
	if (unlikely(!valid)) return;
	size_t s_out   = stage_indices[stage+1];
	if (unlikely(ptr != PTR_TO(buf, objSize,s_out))){
		LOGC(L_DEBUG, "[GenericBuffer<char["+LXS(objSize)+"]>] Program error: called doneStage on other than the stage's output object", ACTOR_ERROR_COLORS);
	} else {
		//cout << "[d"<<stage<<"]";cout.flush();
		stage_indices[stage+1] = (s_out+1) % objCount;
	}
}
bool    GenericBuffer::advStage(size_t stage){
	if (unlikely(stage>=numStages))	FATAL(USAGE_ERROR,"stage index out of range");
	if (unlikely(!valid)) return false;
	void* tmp = nextStage(stage);
	if (!tmp)
		return false;
	else{
		doneStage(stage,tmp);
		return true;
	}
}
bool    GenericBuffer::isValid()const {
	return valid;
}

size_t GenericBuffer::usedInStage(size_t stage)const{
	if (unlikely(stage>=numStages))	FATAL(USAGE_ERROR,"stage index out of range");
	if (unlikely(!valid)) return 0;
	size_t s_in    = stage_indices[stage];
	size_t s_out   = stage_indices[stage+1];
	return RQ_USED(s_in,s_out,objCount);
}
size_t GenericBuffer::used()const{
	if (unlikely(!valid)) return 0;
	size_t s_in    = stage_indices[0];
	size_t s_out   = stage_indices[numStages];
	return RQ_USED(s_in,s_out,objCount);
}
size_t  GenericBuffer::size()const{
	if (unlikely(!valid)) return 0;
	return objCount;
}
void    GenericBuffer::print()const{
	size_t _in  = stage_indices[0];
	size_t _out = stage_indices[numStages];
	size_t _used = used();
	LOGC(L_DEBUG, "[GenericBuffer<char["+LXS(objSize)+"]>] Program error: called doneStage on other than the stage's output object", ACTOR_ERROR_COLORS);
	LOG_START_SESSION(L_DEBUG);
	cout << "[GenericBuffer<char["+LXS(objSize)+"]>] in/out/used" << endl;
	cout << "\t\t\t[ " << setw(10) << _in << " / " << setw(10) << _out << " / " << setw(15) << _used << " ]";
	progressbar((_used*100ll)/objCount,25);
	LOG_END_SESSION();
}

void    GenericBuffer::validitycheck()const{
	if (valid){
		if (!buf)
			FATAL(RUNTIME_ERROR,"valid w/  invalid 'buf' pointer.");
		if (!stage_indices)
			FATAL(RUNTIME_ERROR,"valid w/  invalid 'stage_indices' pointer.");
		if (!numStages)
			FATAL(RUNTIME_ERROR,"valid w/  zero 'numStages'.");
		if (!objCount)
			FATAL(RUNTIME_ERROR,"valid w/  zero 'objCount'.");
		if (!objSize)
			FATAL(RUNTIME_ERROR,"valid w/  zero 'objSize'.");
		for (size_t i=0; i<=numStages; i++){
			size_t idx = stage_indices[i];
			if (idx>=objCount){
				FATAL(RUNTIME_ERROR,"valid w/  invalid stage_indices["<<i<<"]");
			}
		}
	} else {
		FATAL(RUNTIME_ERROR,"invalid w/  appropriately set invalid flag");
	}
}

#ifdef CONFIG_UNIT_TESTS

GenericBuffer* GenericBuffer::utgb=NULL;

#define UT_SIZE   8
#define UT_COUNT  1024
#define UT_STAGES 8
#define UT_BURN   524288ll

void __showStageCounts(GenericBuffer* utgb){
	cout << "<";
	for (size_t i=0; i<UT_STAGES; i++){
		cout << "[" << setw(4) << utgb->usedInStage(i) << "] ";
	}
	cout << ">\n";
}

void __GB_unitTestThread1(){
	GenericBuffer* utgb = GenericBuffer::utgb;
	size_t * t;
	cout << "*********************** TEST 0 ************************************\n";
	for (size_t i=0; i<UT_STAGES; i++){
		t = (size_t *) utgb->peekStage(i,0);
		if (t){
			cout << "edata:<"<<(*t)<<">"<<endl;
			FATAL(UNIT_TEST_FAILURE,"Not empty on initialization");
		}
	}
	__showStageCounts(utgb);
	cout << "*********************** TEST 1 ************************************\n";
	// fill the buffer's first stage
	for (size_t i=0; i<UT_COUNT; i++){
		t = (size_t *) utgb->nextIn();
		//cout << "i=" << setw(4)<< i << ",t="<<(t==NULL)<<"\n";cout.flush();
		if (t==NULL){
			cout << "edata:<"<<((size_t)t)<<">"<<endl;
			FATAL(UNIT_TEST_FAILURE,"Can't insert");
		}else {
			(*t) = (size_t) i;
			utgb->doneIn(t);
		}
	}
	__showStageCounts(utgb);
	cout << "*********************** TEST 2 ************************************\n";
	size_t i=0;
	while (utgb->usedInStage(UT_STAGES-1) != UT_COUNT){
		cout << setw(3)<< i<<":  "; __showStageCounts(utgb);
		for (size_t j=UT_STAGES-1; j>0; j--){
			size_t predcount = utgb->usedInStage(j-1);
			size_t movecount = (predcount/2) + ((predcount & 0x01)?1:0);
			//cout << "\t" << j << ":  " << predcount << "\n";
			for (size_t q=0; q<movecount; q++){
				if (!utgb->advStage(j-1)){
					FATAL(UNIT_TEST_FAILURE,"Can't advance prior stage");
				}
			}
		}
		i++;
	}
	cout << setw(3)<< i<<":  "; __showStageCounts(utgb);
	cout << "*********************** TEST 3 ************************************\n";
	for (size_t i=0; i<UT_COUNT; i++){
			t = (size_t *) utgb->nextOut();
			//cout << "i=" << setw(4)<< i << ",t="<<(t==NULL)<<"\n";cout.flush();
			if (t==NULL){
				cout << "edata:<"<<((size_t)t)<<">"<<endl;
				FATAL(UNIT_TEST_FAILURE,"Can't remove");
			}else {
				if ((*t) != (size_t) i){
					FATAL(UNIT_TEST_FAILURE,"Incorrect value returned");
				} else {
					utgb->doneOut(t);
				}
			}
		}
	__showStageCounts(utgb);

}

void __GB_unitTest_Producer(){
	GenericBuffer* utgb = GenericBuffer::utgb;
	size_t * t;
	size_t val = 0;
	cout << "Producer Thread started\n";
	while(val <= UT_BURN){
		t=(size_t *)utgb->nextIn();
		if (t){
			//cout << "+"; cout.flush();
			*t=val;
			utgb->doneIn(t);
			val++;
		}
	}
	cout << "Producer Thread finished\n";
}

void __GB_unitTest_StageN_Consumer(size_t stage){
	GenericBuffer* utgb = GenericBuffer::utgb;
	size_t * t;
	size_t val = 0;
	boost::random::mt19937 rng;
	boost::random::uniform_size_t_distribution<> delay(0,1000);
	cout << "Consumer Thread #"<<stage<<" started\n";
	do {
		t=(size_t *)utgb->nextStage(stage);
		if (t){
			if ((*t) != val){
				cout << "edata:["<<stage<<","<<(*t)<<"]\n";
				FATAL(UNIT_TEST_FAILURE,"Incorrect value returned");
			}
			//cout << stage; cout.flush();
			utgb->doneStage(stage,(void*)t);
			val++;
		}
	} while(val <= UT_BURN);
	cout << "Consumer Thread #"<<stage<<" finished\n";
}

void GenericBuffer::unitTest(){
	if (!utgb)
		utgb = new GenericBuffer(UT_SIZE, UT_COUNT, UT_STAGES);
	if (!utgb){
		FATAL(UNIT_TEST_FAILURE,"Can't create generic buffer");
	}
	cout << "Beginning GenericBuffer Unit Test\n";
	cout << "Launch thread 1\n";
	boost::thread utt1(__GB_unitTestThread1);
	cout << "Sleep on join thread 1\n";
	utt1.join();

	cout << "Launch Producer\n";
	boost::thread p(__GB_unitTest_Producer);
	boost::thread * c[UT_STAGES];
	for (size_t i=0; i<UT_STAGES; i++){
		cout << "Launch Consumer #"<<i<<"\n";
		c[i] = new boost::thread(__GB_unitTest_StageN_Consumer, i);
	}
	cout << "Sleep on join Producer\n";
	p.join();
	for (size_t i=0; i<UT_STAGES; i++){
		cout << "Sleep on join Consumer #"<<i<<"\n";
		c[i]->join();
		delete(c[i]);
	}

	cout << "Finished\n";
}
#endif





