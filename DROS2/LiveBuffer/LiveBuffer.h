// ========================= DROSv2 License preamble===========================
// Software for DROSv2 is covered jointly under GPLv3 and Boost 1.0 licenses,
// to the extent required by included Boost sources and GPL sources, and to the
// more restrictive case pertaining thereunto, as defined herebelow. Beyond those
// requirements, any code not explicitly restricted by either of thowse two license
// models shall be deemed to be licensed under the GPLv3 license and subject to
// those restrictions.
//
// Copyright 2012, Virginia Tech, University of New Mexico, and Christopher Wolfe
//
// ========================= Boost License ====================================
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// =============================== GPL V3 ====================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


	// //////////////////////////////////////////////////////////////////////////////////
	// Live buffer consists of two threads w/ asynchronous control,
	// M buffers each N frames in length, with frames of variable size
	// Thread 1 is responsible for receiving the frames from
	// Ticket buffer it is attached to.
	// Thread 2 is responsible for offloading filled buffers,
	// either automatically, or in response to explicit requests for contents
	//
	//   |<------------ N ------------------>|
	//   _____________________________________ _______
	//   |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|       ^
	//   _____________________________________       |
	//   |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|       |
	//   _____________________________________       |
	//   |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
	//   _____________________________________       M
	//   |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
	//                                               |
	//                ...                            |
	//   _____________________________________       v
	//   |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| _______
	//
	//
	//   While filling an individual buffer of size N:
	//   _____________________________________
	//   |#|#|#|#|#|#|#|#|#|#|#|_|_|_|_|_|_|_|
	//
	//   |<-------- n -------->|             |      n: count filled
	//
	//
	//   While draining an individual buffer of size N:
	//   _____________________________________
	//   |_|_|_|_|_|_|#|#|#|#|#|#|#|#|#|#|#|#|
	//
	//   |<--- n --->|                       |      n: count sent
	//
	// //////////////////////////////////////////////////////////////////////////////////
	//
	//   Each individual (1 of M) buffer's state machine is as follows:
	//   Double arrows are automatic, single are event driven
	//   ...............................................................................
	//   .............                                                      __________ .
	//   ................                                                   |thread 1| .
	//   ...................                                                |__owns__| .
	//   ......................            _______                                     .
	//   .......................   u==N   / Empty \  frm in         frm in             .
	//   ....................... /+======>\_______/--------+  +-----------------+      .
	//   ....................... || ..                     |  |                 |      .
	//   ....................... || .....                  |  |                 |      .
	//   ...________..........___||__.......              _v__v__    u!=N    ___|___   .
	//   ../draining\..u!=N../remove \.........          /insert \=========>/filling\  .
	//   ..\________/<=======\_______/............       \_______/          \_______/  .
	//   ..... | .............. ^  ^ ................       ||                         .
	//   ..... | .............. |  | frm................    ||                         .
	//   ..... |    frm out     |  | out  ._______.....u==N ||                         .
	//   ..... +----------------+  +------/ Full  \<========+/                         .
	//   .....                            \_______/.............                       .
	//   .__________...............................................                    .
	//   .|thread 2|..................................................                 .
	//   .|_owns___|.....................................................              .
	//   ...............................................................................
    //

	// //////////////////////////////////////////////////////////////////////////////////
	//                                                                                 //
	//   The total live buffer 'state machine' is as follows.                          //
	//                                                                                 //
	//    _______                                                                      //
	//   / Idle  \ config                                                              //
	//   \_______/---------+                                                           //
	//      ^              |                                                           //
	//      |   +--------+ | -------------------------------+                          //
	//      |   |  reset | | |                              |                          //
	//      |   |       _v_v_v_  trig. cap _______          |                          //
	//      |   +------/ empty \--------->/capture\         |                          //
	//      |          \_______/          \_______/         |                          //
	//      |            |   ^              | ^             |                          //
	//      +------------+   |              | |             |                          //
	//      | deconfig       |reset         | |             |                          //
	//      |                |              | |             |                          //
	//      |           _____|_    complete | |             |                          //
	//      |          /!empty \<-----------+ |             |                          //
	//      +----------\_______/--------------+             |                          //
	//                   ^   |    trigger cap               |                          //
	//                   |   |                              |                          //
	//                   |   | trig                         |                          //
	//                   |   | retrieve    _______          |                          //
	//                   |   +----------->/ drain \---------+                          //
	//                   |                \_______/  complete, m=0                     //
	//                   |                    |                                        //
	//                   +--------------------+                                        //
	//                      complete, m!=0                                             //
	//                                                                                 //
	//                                                                                 //
	// //////////////////////////////////////////////////////////////////////////////////

	//  In reality, state is combination of the following:                             //
	//  where receive state and send state are shared                                  //
	//  .............................................................................  //
	//   Live buffer state       . receive state               . send state            //
	//  .............................................................................  //
	//                           .                             .                       //
	//   _______                 .  _______  trg. cap          .  _______  trg ret.    //
	//  / Idle  \ config         . / empty \-------+           . / !empty\------+      //
	//  \_______/---------+      . \_______/       |           . \_______/      |      //
	//     ^              |      .     ^        ___V___        .     ^       ___V___   //
	//     |   +--------+ |      .     |  no   / have  \       .     |  no  / last  \  //
	//     |   |  reset | |      .     +------/__buf_?__\      .     +-----/__buf_?__\ //
	//     |   |       _v_v___   .     |           | yes       .     |          |yes   //
	//     |   +------/ active\  .     |        ___V___        .     |       ___V___   //
	//     |          \_______/  .     +-------/ !empty\       .     +------/ empty \  //
	//     | deconfig   |        .      last   \_______/       .      new   \_______/  //
	//     +------------+        .      ret.                   .      capture          //
	//                           .                             .                       //
	//                                                                                 //
	//                                                                                 //
	//
	// //////////////////////////////////////////////////////////////////////////////////
	//
	// Triggering rules are as follows
	// I) Capture Trigger
	//     A) periodic: every T seconds, start a capture; T is rounded to timetag intervals
	//     B) explicit: on request, begin capture
    //
	// II) Retrieval Trigger
	//     A) periodic: every T seconds, start a retrieval
	//     B) explicit: on request, begin retrieval (rate-governed)


#ifndef LIVEBUFFER_H_
#define LIVEBUFFER_H_

#include "../Streaming/SubscriberThread.h"
#include "../System/PeriodicReportTimer.h"
#include "../Buffers/LockQueue.h"
#include "Capture.h"
#include "CaptureTransmitter.h"
#include "Trigger.h"

#define DEFAULT_BUFFER_COUNT    (256llu) /* up to 256 buffers */
#define DEFAULT_CHUNKS_PER_BUF  (256llu) /* up to 256 chunks per buffers */

typedef struct __CaptureRule{
	size_t   _N;            // period
	size_t   _N0;           // keep count
	bool     _auto_trigger; // trigger automatically after each capture
	bool     _vampire_full; // reclaim eldest not sent capture if no free capture buffers exist
}CaptureRule;

typedef struct __CaptureState{
	__CaptureState():
		_capturing(false),
		_rule(),
		_ip(NULL),
		_ip_ok(false),
		_rate_limit(0.0),
		_filling(NULL),
		_n(0),
		_fs(0),
		_serv_trg(false),
		_trigger(true),
		_max_chunks_per_buf(0),
		_max_cap_buffs(0),
		_count_cap_buffs(0){
		// nothing to do
	}

	bool          _capturing; 			// currently in the midst of a capture
	CaptureRule   _rule;      			// current configuration

	IpSpec*       _ip;                  // output Ip
	bool          _ip_ok;               // flag indicates address is valid
	struct sockaddr_storage _d_addr;    // output ip, resolved/packed
	double        _rate_limit;          // output rate limit

	Capture*      _filling;   			// current capture buffer

	size_t        _n;         			// current progress
	size_t        _fs;        			// frame size
	bool          _serv_trg;  			// flag indicating completion should include a call to trigger.service();
	Trigger       _trigger;   			// capture trigger

	size_t        _max_chunks_per_buf;  // maximum amount of memory to use
	size_t        _max_cap_buffs;     	// maximum number of capture buffers
	size_t        _count_cap_buffs;   	// number of capture buffers
} CaptureState;








class LiveBuffer: public SubscriberThread {
public:
	LiveBuffer(TicketBuffer* buf);
	virtual ~LiveBuffer();

	// external configuration interface
	void configure_memory(		size_t allocation_limit,
								size_t max_cap_buffs		);
	void configure_capture(		size_t period,
								size_t keep_count,
								bool vampire_full,
								bool auto_trigger_cap		);
	void configure_retrieval(	std::string auto_ip,
								unsigned short auto_port,
								double rate_limit			);

	// internal configuration interface
	bool is_current_config_valid()const;
	void read_config();
	bool check_config();



	// external trigger interface (asynchronous, coalescing)
	void trigger_capture();

	// internal trigger interface (synchronous, coalesced)
	bool check_trigger();
	void reset_trigger();


	// Receiver logic

	void done_filling(bool keep);
	void reset_capture();
	void cancel_capture();

	void onFrameReceived(void* frame, size_t  size);
	void check_config_changes();
	bool acquire_buffer(size_t  size);
	void post_insertion_checks();

	// display status
	void report();

	// Subscriber Thread implementation
	virtual bool onInit();
	// virtual bool onConnected(); /* default ok */
	// virtual bool onReceiveLoopStart(const size_t& size, const size_t& framesize, const size_t& framesPerTicket); /* default ok */
	virtual bool onTicketReceived(TicketBuffer::Ticket* t);
	virtual bool onTicketBufferEmpty(); /* default ok */
	// virtual void onDisonnected(); /* default ok */
	virtual void onUninit();
	virtual void onDone();

private:
	////////////////////////////////////////////
	/// Serialization                        ///
	////////////////////////////////////////////
	DECLARE_ACCESS_MUTEX(config);
	////////////////////////////////////////////
	/// Configuration                        ///
	////////////////////////////////////////////
	size_t              _max_cap_buffs;      		// maximum number of capture buffers
	size_t              _max_chunks_per_buf;   		// maximum number of chunks per buffer
	CaptureRule         _rule;               		// capture rule
	double              _rate_limit;                // output rate limit
	std::string         _auto_ip;                   // output ip
	unsigned short      _auto_port;                 // output port
	volatile bool       _config_changed;            // flag; nomen est omen

	////////////////////////////////////////////
	/// State                                ///
	////////////////////////////////////////////
	CaptureState        _capture_state;      		// capture state
	LockQueue<Capture>  _free_buffers;       		// free capture buffers
	LockQueue<Capture>  _full_buffers;       		// full capture buffers

	////////////////////////////////////////////
	/// Threading                            ///
	////////////////////////////////////////////
	CaptureTransmitter _tx;                  // transmitter thread

	////////////////////////////////////////////
	/// Misc                                 ///
	////////////////////////////////////////////
	PeriodicReportTimer _rptt;
	size_t              _no_ticket_count;
	size_t              _tickets_processed;
	size_t              _frames_processed;
	size_t              _caps_started;
	size_t              _caps_dropped;





};

#endif /* LIVEBUFFER_H_ */
